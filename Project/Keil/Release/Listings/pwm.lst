C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\O
                    -bjects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          volatile u16 c_duty = 0;                 // å½“å‰è®¾ç½®çš„å ç©ºæ¯”
   5          volatile u16 cur_pwm_channel_1_duty = 0; // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”
   6          volatile u16 adjust_duty = MAX_PWM_DUTY; // æœ€ç»ˆè¦è°ƒèŠ‚æˆçš„å ç©ºæ¯”ï¼ˆåªæœ‰å¼€æœºç¼“å¯åŠ¨ã€æ¸©åº
             -¦æ£€æµ‹ã€å‘é€æœºç”µå‹ä¸ç¨³å®šæ£€æµ‹æ‰ä¼šä¿®æ”¹å®ƒçš„å€¼ï¼‰
   7          // volatile u16 max_pwm_duty = MAX_PWM_DUTY;        // å­˜æ”¾å ç©ºæ¯”çš„ä¸Šé™å€¼
   8          
   9          /*
  10              æ ‡å¿—ä½ï¼Œpwm_channel_0 æ˜¯å¦ä½¿èƒ½ï¼ˆåªåœ¨rfé¥æ§å™¨è°ƒèŠ‚ä¸­ä½¿ç”¨ï¼‰
  11              é»˜è®¤ä¸º1ï¼Œé˜²æ­¢åœ¨å®šæ—¶å™¨è°ƒèŠ‚pwmæ—¶ä¸å·¥ä½œ
  12          */
  13          volatile bit flag_is_pwm_channel_0_enable = 1;
  14          
  15          /*
  16              æ ‡å¿—ä½ï¼Œpwm_channel_1 æ˜¯å¦ä½¿èƒ½ï¼ˆåªåœ¨rfé¥æ§å™¨è°ƒèŠ‚ä¸­ä½¿ç”¨ï¼‰
  17              é»˜è®¤ä¸º1ï¼Œé˜²æ­¢åœ¨å®šæ—¶å™¨è°ƒèŠ‚pwmæ—¶ä¸å·¥ä½œ
  18          */
  19          volatile bit flag_is_pwm_channel_1_enable = 1;
  20          
  21          #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  22          #define STMR1_PEROID_VAL (SYSCLK / 8000 - 1)
  23          void pwm_init(void)
  24          {
  25   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  26   1      
  27   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  28   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  29   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  30   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  31   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  32   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  33   1      
  34   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  35   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  36   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  37   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  38   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  39   1      
  40   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  41   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  42   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03); // P14 16è„š
  43   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  44   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;      // AFåŠŸèƒ½è¾“å‡º
  45   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  46   1      
  47   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  48   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  49   1          STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  50   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  51   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  52   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 2   

  53   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  54   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºç­‰äºæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºè¾“å‡º0 )
  55   1      
  56   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  57   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  58   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  59   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  60   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  61   1      
  62   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  63   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  64   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  65   1      }
  66          
  67          // 14è„šçš„PWMè°ƒèŠ‚
  68          void set_pwm_duty(void)
  69          {
  70   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((c_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  71   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((c_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  72   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                    // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  73   1      }
  74          
  75          // è®¾ç½®P15 15è„šçš„PWMå ç©ºæ¯”
  76          void set_p15_pwm_duty(u16 set_duty)
  77          {
  78   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((set_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  79   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((set_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  80   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                      // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  81   1      }
  82          
  83          /*
  84              æ»¤æ³¢ã€åˆ¤æ–­ç”µå‹æ˜¯å¦æœ‰è·³åŠ¨ï¼Œä¸€æ®µæ—¶é—´å†…ç”µå‹æµ®åŠ¨è¿‡å¤§ï¼Œ
  85              æ‰€ä½¿ç”¨åˆ°çš„è¿™äº›å˜é‡
  86          */
  87          static u16 t_count = 0;
  88          static u16 t_adc_max = 0;    // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å¤§adå€¼
  89          static u16 t_adc_min = 4096; // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å°adå€¼
  90          static u8 over_drive_status = 0;
  91          #define OVER_DRIVE_RESTART_TIME (30)
  92          
  93          // static volatile u16 filter_buff_2[270] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„
  94          static volatile u16 filter_buff_2[540] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„
  95          static volatile u16 buff_index_2 = 0;         // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ä¸‹æ ‡
  96          
  97          /*
  98              ç”µæºç”µå‹ä½äº170V-AC,å¯åŠ¨ä½å‹ä¿æŠ¤ï¼Œç”µæºç”µå‹é«˜äº170V-ACï¼Œå…³é—­ä½å‹ä¿æŠ¤
  99              æ¸©åº¦æ­£å¸¸ï¼Œæ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
 100              æ³¨æ„ï¼Œæ¯æ¬¡è°ƒç”¨åˆ°è¯¥å‡½æ•°ï¼Œåº”è¯¥åœ¨5.75mså·¦å³ï¼Œæ£€æµ‹å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®šçš„åŸç†æ˜¯
             -æ£€æµ‹é¢‘ç‡ï¼Œ
 101              å¦‚æœä¸åœ¨5.75msé™„è¿‘ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ£€æµ‹ä¸å‡†ç¡®ï¼Œæ£€æµ‹ä¸åˆ°å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®š
 102          */
 103          void according_pin9_to_adjust_pwm(void)
 104          {
 105   1      #define ADC_DEAD_ZONE_NEAR_170VAC (30) // 170VACé™„è¿‘çš„adå€¼æ­»åŒº
 106   1          static volatile u16 filter_buff[32] = {
 107   1              0xFFFF,
 108   1          };
 109   1          static volatile u8 buff_index = 0;
 110   1          static volatile u8 flag_is_sub_power = 0;  // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡ï¼ˆçŠ¶æ€æœºï¼‰
 111   1          static volatile u8 flag_is_sub_power2 = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡
 112   1          static volatile bit flag_is_add_power = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å¢åŠŸç‡
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 3   

 113   1      
 114   1          volatile u32 adc_pin_9_avg = 0; // å­˜æ”¾å¹³å‡å€¼
 115   1      
 116   1          if (filter_buff[0] == 0xFFFF) // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ£€æµ‹ï¼Œè®©æ•°ç»„å†…æ‰€æœ‰å…ƒç´ éƒ½å˜ä¸ºç¬¬ä¸€æ¬¡
             -é‡‡é›†çš„æ•°æ®ï¼Œæ–¹ä¾¿å¿«é€Ÿä½œå‡ºå˜åŒ–
 117   1          {
 118   2              u16 i = 0;
 119   2              for (; i < ARRAY_SIZE(filter_buff); i++)
 120   2              {
 121   3                  filter_buff[i] = adc_val_pin_9;
 122   3              }
 123   2              // for (i = 0; i < 270; i++)
 124   2              for (i = 0; i < 540; i++)
 125   2              {
 126   3                  filter_buff_2[i] = adc_val_pin_9;
 127   3              }
 128   2          }
 129   1          else
 130   1          {
 131   2              u16 temp = filter_buff[buff_index];
 132   2              temp += adc_val_pin_9;
 133   2              temp >>= 1;
 134   2              filter_buff[buff_index] = temp;
 135   2              buff_index++;
 136   2              if (buff_index >= ARRAY_SIZE(filter_buff))
 137   2              {
 138   3                  buff_index = 0;
 139   3              }
 140   2          }
 141   1      
 142   1          { // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 143   2              u16 i = 0;
 144   2              for (; i < ARRAY_SIZE(filter_buff); i++)
 145   2              {
 146   3                  adc_pin_9_avg += filter_buff[i];
 147   3              }
 148   2      
 149   2              // adc_pin_9_avg /= ARRAY_SIZE(filter_buff);
 150   2              adc_pin_9_avg >>= 5;
 151   2          } // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 152   1      
 153   1          // åœ¨å‰é¢æ»¤æ³¢çš„åŸºç¡€ä¸Šå†è¿›è¡Œä¸€æ¬¡æ»¤æ³¢
 154   1          filter_buff_2[buff_index_2] = adc_pin_9_avg;
 155   1          buff_index_2++;
 156   1          // if (buff_index_2 >= 270)
 157   1          if (buff_index_2 >= 540)
 158   1          {
 159   2              buff_index_2 = 0;
 160   2          }
 161   1      
 162   1      #if USE_MY_DEBUG
 163   1          // printf(",b=%lu,", adc_pin_9_avg);
 164   1      #endif
 165   1      
 166   1          {
 167   2              u16 i = 0;
 168   2              t_adc_max = 0;
 169   2              t_adc_min = 4096;
 170   2              // for (; i < 270; i++)
 171   2              for (; i < 540; i++)
 172   2              {
 173   3                  if (filter_buff_2[i] > t_adc_max)
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 4   

 174   3                      t_adc_max = filter_buff_2[i];
 175   3                  if (filter_buff_2[i] < t_adc_min)
 176   3                      t_adc_min = filter_buff_2[i];
 177   3                  if ((t_adc_max - t_adc_min) > 80)
 178   3                  { // ç”µå‹æ³¢åŠ¨
 179   4                      over_drive_status = OVER_DRIVE_RESTART_TIME;
 180   4                  }
 181   3                  else
 182   3                  {
 183   4                      if (over_drive_status)
 184   4                          over_drive_status--;
 185   4                  }
 186   3              }
 187   2      
 188   2              // {
 189   2              //     static u8 cnt = 0;
 190   2              //     cnt++;
 191   2              //     if (cnt >= 100)
 192   2              //     {
 193   2              //         cnt = 0;
 194   2              //         printf("__LINE__ %u\n", __LINE__);
 195   2              //     }
 196   2              // }
 197   2          }
 198   1      
 199   1          if (adc_pin_9_avg >= (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC) || (flag_is_add_power && adc_pin_9_av
             -g > (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC))) // å¤§äº 170VAC
 200   1          {
 201   2              // å¤§äº170VACï¼Œæ¢å¤100%å ç©ºæ¯”ï¼Œä½†æ˜¯ä¼˜å…ˆçº§æ¯” "9è„šç”µå‹æ£€æµ‹åˆ°å‘é€æœºåŠŸç‡ä¸ç
             -¨³å®šï¼Œè¿›è€Œé™åŠŸç‡" ä½
 202   2              flag_is_sub_power = 0;
 203   2              flag_is_sub_power2 = 0;
 204   2              flag_is_add_power = 1;
 205   2      #if 0
                      // åˆ¤æ–­æ˜¯å¦å˜åŒ–PWM
                      if (adc_pin_9_avg > ADC_VAL_WHEN_UNSTABLE) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå‹
                      {
                          if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
                          {
                              flag_is_pwm_sub_time_comes = 0;
                              // è¿‡è½½ pwm--
                              // if (adjust_duty > PWM_DUTY_50_PERCENT)
                              if (adjust_duty > PWM_DUTY_30_PERCENT)
                              {
                                  adjust_duty -= 1;
                              }
                              else
                              {
                                  // adjust_duty = PWM_DUTY_50_PERCENT;
                                  adjust_duty = PWM_DUTY_30_PERCENT;
                              }
                          }
                      }
                      else if (adc_pin_9_avg < (ADC_VAL_WHEN_UNSTABLE - 50))
                      {
                          // æœªæ»¡è½½ pwm++
                          if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
                          {
                              flag_is_pwm_add_time_comes = 0;
                              if (adjust_duty < 6000)
                              {
                                  adjust_duty++;
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 5   

                              }
                          }
                      }
              #else
 238   2              if (over_drive_status == OVER_DRIVE_RESTART_TIME) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå
             -‹
 239   2              {
 240   3                  over_drive_status -= 1;
 241   3                  if (adjust_duty > PWM_DUTY_50_PERCENT)
 242   3                  {
 243   4                      // adjust_duty -= 300; // å˜åŒ–å¤ªå¤§ï¼Œä¼šé€ æˆç¯å…‰é—ªçƒ
 244   4                      adjust_duty -= 1;
 245   4                  }
 246   3      
 247   3                  if (adjust_duty < PWM_DUTY_50_PERCENT)
 248   3                  {
 249   4                      adjust_duty = PWM_DUTY_50_PERCENT;
 250   4                  }
 251   3              }
 252   2              else if (over_drive_status == 0)
 253   2              {
 254   3                  // æœªæ»¡è½½ pwm++
 255   3                  if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
 256   3                  {
 257   4                      flag_is_pwm_add_time_comes = 0;
 258   4                      if (adjust_duty < PWM_DUTY_100_PERCENT)
 259   4                      {
 260   5                          adjust_duty++;
 261   5                      }
 262   4                  }
 263   3              }
 264   2      #endif
 265   2          }
 266   1          else if (adc_pin_9_avg > (1475) && (adc_pin_9_avg <= (1645 /*1475*/) || flag_is_sub_power == 4)) // å°
             -äº 170VAC
 267   1          {
 268   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 269   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 270   2              {
 271   3                  flag_is_pwm_sub_time_comes = 0;
 272   3                  // if (flag_is_sub_power == 0)
 273   3                  //     flag_is_sub_power = 1;
 274   3                  // else if (flag_is_sub_power == 1)
 275   3                  //     flag_is_sub_power = 2;
 276   3                  if (flag_is_sub_power < 4)
 277   3                      flag_is_sub_power++;
 278   3      
 279   3                  flag_is_sub_power2 = 0;
 280   3                  flag_is_add_power = 0;
 281   3      
 282   3                  if (adjust_duty > PWM_DUTY_50_PERCENT)
 283   3                  // if (adjust_duty > PWM_DUTY_30_PERCENT)
 284   3                  {
 285   4                      adjust_duty -= 2;
 286   4                  }
 287   3                  else if (adjust_duty < PWM_DUTY_50_PERCENT)
 288   3                  {
 289   4                      adjust_duty++;
 290   4                  }
 291   3                  else
 292   3                  {
 293   4                      adjust_duty = PWM_DUTY_50_PERCENT;
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 6   

 294   4                  }
 295   3              }
 296   2          }
 297   1          else if (adc_pin_9_avg <= (1475) || (flag_is_sub_power2)) // å°äº 170VAC
 298   1          {
 299   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 300   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 301   2              {
 302   3                  flag_is_pwm_sub_time_comes = 0;
 303   3                  // if (flag_is_sub_power2 < 4)
 304   3                  //     flag_is_sub_power2++;
 305   3      
 306   3                  flag_is_sub_power2 = 1;
 307   3                  flag_is_sub_power = 0;
 308   3                  flag_is_add_power = 0;
 309   3      
 310   3                  // if (adjust_duty > PWM_DUTY_50_PERCENT)
 311   3                  if (adjust_duty > PWM_DUTY_30_PERCENT)
 312   3                  {
 313   4                      adjust_duty -= 2;
 314   4                  }
 315   3                  else
 316   3                  {
 317   4                      // adjust_duty = PWM_DUTY_50_PERCENT;
 318   4                      adjust_duty = PWM_DUTY_30_PERCENT;
 319   4                  }
 320   3              }
 321   2          }
 322   1      }
 323          
 324          // æ ¹æ®9è„šçš„ç”µå‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡å‹ä¿æŠ¤ï¼‰
 325          void according_pin9_to_adjust_pin16(void)
 326          {
 327   1          // å½“9è„šç”µå‹é«˜äº 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºæ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºå…³æœºï¼‰ã
             -€‚
 328   1          // if (adc_val_pin_9 >= 3511)
 329   1          // {
 330   1          //     P14 = 1;
 331   1          // }
 332   1          // else if (adc_val_pin_9 <= 3511 - 40)
 333   1          {
 334   2              P14 = 0;
 335   2          }
 336   1      }
 337          
 338          /**
 339           * @brief è·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
 340           *
 341           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 342           */
 343          u8 get_pwm_channel_0_status(void)
 344          {
 345   1          if (STMR_PWMEN & 0x01) // å¦‚æœpwm0ä½¿èƒ½
 346   1          {
 347   2              return 1;
 348   2          }
 349   1          else // å¦‚æœpwm0æœªä½¿èƒ½
 350   1          {
 351   2              return 0;
 352   2          }
 353   1      }
 354          
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 7   

 355          /**
 356           * @brief è·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 357           *
 358           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 359           */
 360          u8 get_pwm_channel_1_status(void)
 361          {
 362   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æœpwm1ä½¿èƒ½
 363   1          {
 364   2              return 1;
 365   2          }
 366   1          else // å¦‚æœ pwm æœªä½¿èƒ½
 367   1          {
 368   2              return 0;
 369   2          }
 370   1      }
 371          
 372          void pwm_channel_0_enable(void)
 373          {
 374   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 375   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 376   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 377   1      }
 378          
 379          void pwm_channel_0_disable(void)
 380          {
 381   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 382   1          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 383   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 384   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 385   1      }
 386          
 387          void pwm_channel_1_enable(void)
 388          {
 389   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 390   1          STMR_PWMEN |= 0x01 << 1;           // ä½¿èƒ½PWM1çš„è¾“å‡º
 391   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 392   1      }
 393          
 394          
 395          void pwm_channel_1_disable(void)
 396          {
 397   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 398   1          STMR_PWMEN &= ~(0x01 << 1);   // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 399   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
 400   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 401   1      }
 402          
 403          // void alter_adjust_pwm_duty(u16 set_pwm_duty)
 404          
 405          /**
 406           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æ§è°ƒå…‰çš„é™åˆ¶ï¼Œè®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆåªåœ¨ pwm_channel
             -_0 è¿™ä¸€è·¯æœ‰æ•ˆï¼‰
 407           * 
 408           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰
 409           * 
 410           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 411           */ 
 412          u16 get_pwm_channel_0_adjust_duty(u16 pwm_adjust_duty)
 413          {
 414   1          adjust_duty = pwm_adjust_duty; // è®¾å®šç›®æ ‡å ç©ºæ¯” 
 415   1          // æ ¹æ®è®¾å®šçš„ç›®æ ‡å ç©ºæ¯”ï¼Œæ›´æ–°ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„ç›®æ ‡å ç©ºæ¯”ï¼š
C51 COMPILER V9.60.7.0   PWM                                                               06/05/2025 17:34:21 PAGE 8   

 416   1          limited_adjust_pwm_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * æ—‹
             -é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 417   1          return limited_adjust_pwm_duty; // è¿”å›ç»è¿‡çº¿æ§è°ƒå…‰é™åˆ¶ä¹‹åçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 418   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1428    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1162       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
