C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDIR
                    -(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\O
                    -bjects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          // volatile bit flag_is_pin_9_vol_bounce = 0; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨
   8          
   9          // adcç›¸å…³çš„å¼•è„šé…ç½®
  10          void adc_pin_config(void)
  11          {
  12   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  13   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  14   1      
  15   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  16   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  17   1      
  18   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  19   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  20   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  21   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  22   1      }
  23          
  24          // åˆ‡æ¢adcé‡‡é›†çš„å¼•è„šï¼Œé…ç½®å¥½adc
  25          // å‚æ•°å¯ä»¥é€‰æ‹©ï¼š
  26          // ADC_SEL_PIN_GET_TEMP
  27          // ADC_SEL_PIN_GET_VOL
  28          void adc_sel_pin(const u8 adc_sel)
  29          {
  30   1          // åˆ‡æ¢é‡‡é›†å¼•è„šæ—¶ï¼ŒæŠŠä¹‹å‰é‡‡é›†åˆ°çš„adå€¼æ¸…ç©º
  31   1          // adc0_val = 0;
  32   1          static u8 last_adc_sel = 0;
  33   1          if (last_adc_sel == adc_sel)
  34   1          {
  35   2              // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€€å‡
             -º
  36   2              return;
  37   2          }
  38   1      
  39   1          last_adc_sel = adc_sel;
  40   1      
  41   1          ADC_CFG1 |= (0x0F << 3); // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  42   1          ADC_CFG2 = 0xFF; // é€šé“0é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
  43   1      
  44   1          switch (adc_sel)
  45   1          {
  46   2          case ADC_SEL_PIN_GET_TEMP: // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹åº”çš„ç”µå‹çš„å¼•è„šï¼ˆ8è„šï¼‰
  47   2      
  48   2              // ADCé…ç½®
  49   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  50   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 2   

  51   2                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  52   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  53   2                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  54   2                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  55   2      
  56   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  57   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  58   2              ADC_CFG0 |= ADC_CHAN0_EN(0x1) |    // ä½¿èƒ½é€šé“0è½¬æ¢
  59   2                          ADC_EN(0x1);           // ä½¿èƒ½A/Dè½¬æ¢
  60   2              break;
  61   2      
  62   2          case ADC_SEL_PIN_GET_VOL: // æ£€æµ‹å›è·¯ç”µå‹çš„å¼•è„šï¼ˆ9è„šï¼‰
  63   2      
  64   2              // ADCé…ç½®
  65   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€‰æ‹
             -©çš„å‚è€ƒç”µå‹
  66   2              // ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  67   2              //              ADC_TEN_SEL(0x3);
  68   2              ADC_ACON1 |= ADC_VREF_SEL(0x5) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ‰‹å†Œè¯´æœªæ ¡å‡†)
  69   2                           ADC_TEN_SEL(0x3);     /* å…³é—­æµ‹è¯•ä¿¡å· */
  70   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  71   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  72   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  73   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
  74   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  75   2              ADC_CFG0 |= ADC_CHAN0_EN(0x1) |    // ä½¿èƒ½é€šé“0è½¬æ¢
  76   2                          ADC_EN(0x1);           // ä½¿èƒ½A/Dè½¬æ¢
  77   2      
  78   2              break;
  79   2      
  80   2          case ADC_SEL_PIN_P31: // P31ã€7è„šï¼Œæ£€æµ‹æ—‹é’®è°ƒå…‰
  81   2      
  82   2              // ADCé…ç½®
  83   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  84   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  85   2                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  86   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  87   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  88   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  89   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
  90   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  91   2              ADC_CFG0 |= ADC_CHAN0_EN(0x1) |    // ä½¿èƒ½é€šé“0è½¬æ¢
  92   2                          ADC_EN(0x1);           // ä½¿èƒ½A/Dè½¬æ¢
  93   2              break;
  94   2          }
  95   1      
  96   1          delay_ms(1); // ç­‰å¾…ADCç¨³å®š
  97   1      }
  98          
  99          // adcå®Œæˆä¸€æ¬¡è½¬æ¢
 100          // è½¬æ¢å¥½çš„å€¼æ”¾å…¥å…¨å±€å˜é‡ adc0_val ä¸­
 101          // éœ€è¦æ³¨æ„ï¼Œè¿™æ¬¾èŠ¯ç‰‡çš„adcä¸èƒ½é¢‘ç¹é‡‡é›†ï¼Œéœ€è¦å»¶æ—¶ä¸€ä¸‹å†é‡‡é›†ä¸€æ¬¡
 102          // void adc_single_getval(void)
 103          // {
 104          //     ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 105          //     while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 106          //         ;                                             // ç­‰å¾…è½¬æ¢å®Œæˆ
 107          //     adc0_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å–channel0çš„å€¼
 108          //     ADC_STA = ADC_CHAN0_DONE(0x1);                    // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 3   

 109          // }
 110          
 111          // è·å–ä¸€æ¬¡adcé‡‡é›†+æ»¤æ³¢åçš„å€¼
 112          u16 adc_get_val(void)
 113          {
 114   1          u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 115   1          volatile u16 g_temp_value = 0;
 116   1          volatile u32 g_tmpbuff = 0;
 117   1          volatile u16 g_adcmax = 0;
 118   1          volatile u16 g_adcmin = 0xFFFF;
 119   1      
 120   1          // é‡‡é›†20æ¬¡ï¼Œå»æ‰å‰ä¸¤æ¬¡é‡‡æ ·ï¼Œå†å»æ‰ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼Œå†å–å¹³å‡å€¼
 121   1          for (i = 0; i < 20; i++)
 122   1          {
 123   2              ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 124   2              while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 125   2                  ;                                                 // ç­‰å¾…è½¬æ¢å®Œæˆ
 126   2              g_temp_value = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å– channel0 çš„å€¼
 127   2              ADC_STA = ADC_CHAN0_DONE(0x1);                        // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 128   2      
 129   2              if (i < 2)
 130   2                  continue; // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·çš„
 131   2              if (g_temp_value > g_adcmax)
 132   2                  g_adcmax = g_temp_value; // æœ€å¤§
 133   2              if (g_temp_value < g_adcmin)
 134   2                  g_adcmin = g_temp_value; // æœ€å°
 135   2      
 136   2              g_tmpbuff += g_temp_value;
 137   2          }
 138   1      
 139   1          g_tmpbuff -= g_adcmax;           // å»æ‰ä¸€ä¸ªæœ€å¤§
 140   1          g_tmpbuff -= g_adcmin;           // å»æ‰ä¸€ä¸ªæœ€å°
 141   1          g_temp_value = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 142   1      
 143   1          return g_temp_value;
 144   1      }
 145          
 146          
 147          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 148          u32 get_voltage_from_pin(void)
 149          {
 150   1          volatile u32 adc_aver_val = 0; // å­˜æ”¾adcæ»¤æ³¢åçš„å€¼
 151   1          // é‡‡é›†çƒ­æ•ç”µé˜»çš„ç”µå‹
 152   1          adc_aver_val = adc_get_val();
 153   1      
 154   1          // 4095ï¼ˆadcè½¬æ¢åï¼Œå¯èƒ½å‡ºç°çš„æœ€å¤§çš„å€¼ï¼‰ * 0.0012 == 4.914ï¼Œçº¦ç­‰äº5Vï¼ˆVCCï¼‰
 155   1          return adc_aver_val * 12 / 10; // å‡è®¾æ˜¯4095ï¼Œ4095 * 12/10 == 4915mV
 156   1      }
 157          
 158          
 159          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 160          void temperature_scan(void)
 161          {
 162   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 163   1      
 164   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡30minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå
             -› ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 165   1          // if (TEMP_75_30MIN == temp_status)
 166   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 167   1          if (TEMP_75_5_MIN == temp_status)
 168   1          {
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 4   

 169   2              return;
 170   2          }
 171   1      
 172   1      
 173   1          adc_sel_pin(ADC_SEL_PIN_GET_TEMP); // å…ˆåˆ‡æ¢æˆçƒ­æ•ç”µé˜»å¯¹åº”çš„å¼•è„šçš„adcé…ç½®
 174   1          voltage = get_voltage_from_pin();  // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 175   1      
 176   1      #if USE_MY_DEBUG
 177   1          // printf("PIN-8 voltage: %lu mV\n", voltage);
 178   1      #endif // USE_MY_DEBUG
 179   1      
 180   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 181   1          if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 182   1          {
 183   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 184   2      
 185   2              {
 186   3                  // æ£€æµ‹10æ¬¡ï¼Œå¦‚æœ10æ¬¡éƒ½å°äºè¿™ä¸ªç”µå‹å€¼ï¼Œæ‰è¯´æ˜æ¸©åº¦çœŸçš„å¤§äº75æ‘„æ°åº¦
 187   3                  u8 i = 0;
 188   3                  for (i = 0; i < 10; i++)
 189   3                  {
 190   4                      voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 191   4                      if (voltage > VOLTAGE_TEMP_75)
 192   4                      {
 193   5                          // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
 194   5                          temp_status = TEMP_NORMAL;
 195   5                          return;
 196   5                      }
 197   4                  }
 198   3      
 199   3                  // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜æ¸©åº¦ç¡®å®å¤§äº75æ‘„æ°åº¦
 200   3      #if USE_MY_DEBUG
 201   3      // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦\n");
 202   3      // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV", voltage);
 203   3      #endif
 204   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦
 205   3                  return;                // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 206   3              }
 207   2      
 208   2              // static u8 flag_adc_filter = 0;
 209   2              // flag_adc_filter <<= 1;
 210   2              // if (voltage > VOLTAGE_TEMP_75) // ç”µå‹å€¼å¤§äº75åº¦å¯¹åº”çš„ç”µå‹ï¼Œè¯´æ˜æ¸©åº¦å°äº75åº¦
 211   2              // {
 212   2              //     flag_adc_filter = 0;
 213   2              // }
 214   2              // else
 215   2              // {
 216   2              //     flag_adc_filter |= 1;
 217   2              // }
 218   2      
 219   2              // if (flag_adc_filter == 0xFF)
 220   2              // {
 221   2              // }
 222   2          }
 223   1          else if (temp_status == TEMP_75)
 224   1          {
 225   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 226   2              static bit tmr1_is_open = 0;
 227   2      
 228   2              if (0 == tmr1_is_open)
 229   2              {
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 5   

 230   3                  tmr1_is_open = 1;
 231   3                  tmr1_cnt = 0;
 232   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡30min
 233   3              }
 234   2      
 235   2              // while (1) // è¿™ä¸ªwhileå¾ªç¯ä¼šå½±å“åˆ°9è„šè°ƒèŠ‚16è„šç”µå‹çš„åŠŸèƒ½
 236   2              // {
 237   2      #if 0 // è¿™é‡Œçš„ä»£ç åœ¨å®¢æˆ·é‚£è¾¹åè€Œå‡ºç°é—®é¢˜ï¼Œè¶…è¿‡90æ‘„æ°åº¦ä¸”1ä¸ªå°æ—¶éƒ½æ²¡æœ‰å°†PWMé
             -™åˆ°25%ï¼Œ
                    // å¯èƒ½æ˜¯ç”¨æˆ·é‚£è¾¹çš„ç”µå‹æœ‰è·³å˜ï¼Œå¯¼è‡´è¿™é‡Œæ¸…ç©ºäº†å®šæ—¶å™¨è®¡æ•°
                          if (voltage > VOLTAGE_TEMP_75)
                          {
                              // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
                              temp_status = TEMP_75; // æ¸©åº¦æ ‡è®°ä¸ºè¶…è¿‡75æ‘„æ°åº¦ï¼Œä½†æ˜¯æ²¡æœ‰ç´¯è®¡30min
                              tmr1_disable();        // å…³é—­å®šæ—¶å™¨
                              tmr1_cnt = 0;          // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
              #if USE_MY_DEBUG
                              // printf("åœ¨æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦æ—¶ï¼Œæ£€æµ‹åˆ°æœ‰ä¸€æ¬¡æ¸©åº¦æ²¡æœ‰è¶…è¿‡75æ‘„æ°
             -åº¦\n");
                              // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV\n", voltage);
              #endif
                              return;
                          }
              #endif
 252   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†30minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 253   2              // if (tmr1_cnt >= (u32)TMR1_CNT_30_MINUTES)
 254   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 255   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 256   2              {
 257   3                  u8 i = 0;
 258   3      #if USE_MY_DEBUG
 259   3                  // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦ä¸”è¶…è¿‡äº†30min\n");
 260   3                  // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV\n", voltage);
 261   3      #endif
 262   3      
 263   3                  for (i = 0; i < 10; i++)
 264   3                  {
 265   4                      voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 266   4                      if (voltage > VOLTAGE_TEMP_75)
 267   4                      {
 268   5                          // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
 269   5                          temp_status = TEMP_75;
 270   5                          return;
 271   5                      }
 272   4                  }
 273   3      
 274   3                  // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ä¸Šé¢è¿ç»­ã€å¤šæ¬¡æ£€æµ‹åˆ°çš„æ¸©åº¦éƒ½å¤§äº75æ‘„æ°åº¦
 275   3                  // temp_status = TEMP_75_30MIN;
 276   3                  temp_status = TEMP_75_5_MIN;
 277   3                  tmr1_disable(); // å…³é—­å®šæ—¶å™¨
 278   3                  tmr1_cnt = 0;   // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 279   3                  tmr1_is_open = 0;
 280   3                  return;
 281   3              }
 282   2              // }  // while(1)
 283   2          }
 284   1      }
 285          
 286          
 287          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 288          void set_duty(void)
 289          {
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 6   

 290   1          // static bit tmr0_is_open = 0;
 291   1      
 292   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 293   1          if (TEMP_NORMAL == temp_status)
 294   1          { 
 295   2      
 296   2              according_pin9_to_adjust_pwm();
 297   2              // Adaptive_Duty(); // è°ƒèŠ‚å ç©ºæ¯”
 298   2      #if USE_MY_DEBUG
 299   2              // printf("cur duty: %d\n", c_duty);
 300   2      #endif
 301   2          }
 302   1          else if (TEMP_75 == temp_status)
 303   1          {
 304   2              // å¦‚æœæ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦ä¸”ç´¯è®¡10min
 305   2              // tmr0_disable(); // å…³é—­å®šæ—¶å™¨0ï¼Œä¸ä»¥9è„šçš„ç”µå‹æ¥è°ƒèŠ‚PWM
 306   2              // tmr0_is_open = 0;
 307   2              // è®¾å®šå ç©ºæ¯”
 308   2              adjust_duty = PWM_DUTY_50_PERCENT;
 309   2              // while (c_duty != adjust_duty) // å¦‚æœæœ‰æ—‹é’®è°ƒå…‰åŠŸèƒ½ï¼Œè¿™ä¸ªå¾ªç¯å°±ä¼šå¡ä½ï¼Œæ— æ³
             -•é€€å‡º
 310   2              {
 311   3                  // Adaptive_Duty(); // è°ƒèŠ‚å ç©ºæ¯”
 312   3              }
 313   2          }
 314   1          // else if (TEMP_75_30MIN == temp_status)
 315   1          else if (TEMP_75_5_MIN == temp_status)
 316   1          {
 317   2              // tmr0_disable(); // å…³é—­å®šæ—¶å™¨0ï¼Œä¸ä»¥9è„šçš„ç”µå‹æ¥è°ƒèŠ‚PWM
 318   2              // tmr0_is_open = 0;
 319   2              // è®¾å®šå ç©ºæ¯”
 320   2              adjust_duty = PWM_DUTY_25_PERCENT;
 321   2              // while (c_duty != adjust_duty) // å¦‚æœæœ‰æ—‹é’®è°ƒå…‰åŠŸèƒ½ï¼Œè¿™ä¸ªå¾ªç¯å°±ä¼šå¡ä½ï¼Œæ— æ³
             -•é€€å‡º
 322   2              {
 323   3                  // Adaptive_Duty(); // è°ƒèŠ‚å ç©ºæ¯”
 324   3              }
 325   2          }
 326   1      }
 327          
 328          volatile u16 adc_val_pin_9 = 0; // å­˜æ”¾9è„šé‡‡é›†åˆ°çš„adå€¼
 329          // volatile u16 adc_val_pin_9_filter_count = 0;
 330          // u16 adc_val_pin_9_temp;
 331          // æ›´æ–°9è„šé‡‡é›†çš„adå€¼
 332          void adc_update_pin_9_adc_val(void)
 333          {
 334   1          adc_sel_pin(ADC_SEL_PIN_GET_VOL);
 335   1          adc_val_pin_9 = adc_get_val();
 336   1      
 337   1      #if USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 338   1          // printf("adc_val_pin_9 %u\n", adc_val_pin_9);
 339   1          
 340   1          // printf(",a=%u,", adc_val_pin_9);
 341   1      #endif // USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 342   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    875    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4      20
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   ADC                                                               06/04/2025 14:59:13 PAGE 7   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
