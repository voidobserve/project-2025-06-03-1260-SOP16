C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          // volatile bit flag_is_pin_9_vol_bounce = 0; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨
   8          
   9          // adcç›¸å…³çš„å¼•è„šé…ç½®
  10          void adc_pin_config(void)
  11          {
  12   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  13   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  14   1      
  15   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  16   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  17   1      
  18   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  19   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  20   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  21   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  22   1      
  23   1          // P13 -- èŠ¯ç‰‡çš„1è„šï¼Œé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  24   1          P1_PU &= ~(0x01 << 3);             // å…³é—­ä¸Šæ‹‰
  25   1          P1_PD &= ~(0x01 << 3);             // å…³é—­ä¸‹æ‹‰
  26   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x03); // æ¨¡æ‹ŸIOå·¥ä½œæ¨¡å¼
  27   1      }
  28          
  29          // åˆ‡æ¢adcé‡‡é›†çš„å¼•è„šï¼Œé…ç½®å¥½adc
  30          // å‚æ•°å¯ä»¥é€‰æ‹©ï¼š
  31          // ADC_SEL_PIN_GET_TEMP
  32          // ADC_SEL_PIN_GET_VOL
  33          void adc_sel_pin(const u8 adc_sel)
  34          {
  35   1          // åˆ‡æ¢é‡‡é›†å¼•è„šæ—¶ï¼ŒæŠŠä¹‹å‰é‡‡é›†åˆ°çš„adå€¼æ¸…ç©º
  36   1          // adc0_val = 0;
  37   1          static u8 last_adc_sel = 0;
  38   1          if (last_adc_sel == adc_sel)
  39   1          {
  40   2              // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€€å‡
             -º
  41   2              return;
  42   2          }
  43   1      
  44   1          last_adc_sel = adc_sel;
  45   1      
  46   1          ADC_CFG1 |= (0x0F << 3); // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  47   1          ADC_CFG2 = 0xFF;         // é€šé“0é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
  48   1      
  49   1          switch (adc_sel)
  50   1          {
  51   2          case ADC_SEL_PIN_GET_TEMP: // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹åº”çš„ç”µå‹çš„å¼•è„šï¼ˆ8è„šï¼‰
  52   2      
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 2   

  53   2              // ADCé…ç½®
  54   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  55   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
  56   2                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  57   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  58   2                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  59   2                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  60   2      
  61   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  62   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  63   2      
  64   2              break;
  65   2      
  66   2          case ADC_SEL_PIN_GET_VOL: // æ£€æµ‹å›è·¯ç”µå‹çš„å¼•è„šï¼ˆ9è„šï¼‰
  67   2      
  68   2              // ADCé…ç½®
  69   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€‰æ‹
             -©çš„å‚è€ƒç”µå‹
  70   2              // ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  71   2              //              ADC_TEN_SEL(0x3);
  72   2              ADC_ACON1 |= ADC_VREF_SEL(0x5) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ‰‹å†Œè¯´æœªæ ¡å‡†)
  73   2                           ADC_TEN_SEL(0x3);     /* å…³é—­æµ‹è¯•ä¿¡å· */
  74   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  75   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  76   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  77   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
  78   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  79   2      
  80   2              break;
  81   2      
  82   2          case ADC_SEL_PIN_P31: // P31ã€7è„šï¼Œæ£€æµ‹æ—‹é’®è°ƒå…‰
  83   2      
  84   2              // ADCé…ç½®
  85   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  86   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  87   2                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  88   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  89   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  90   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  91   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
  92   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  93   2      
  94   2              break;
  95   2      
  96   2          case ADC_SEL_PIN_FAN_DETECT: // P13 èŠ¯ç‰‡çš„1è„šï¼Œæ£€æµ‹é£æ‰‡æ˜¯å¦å¼‚å¸¸
  97   2      
  98   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€‰æ‹
             -©çš„å‚è€ƒç”µå‹
  99   2              ADC_ACON1 |= ADC_VREF_SEL(0x5) |                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ
             -‰‹å†Œè¯´æœªæ ¡å‡†)
 100   2                           ADC_TEN_SEL(0x3);                           /* å…³é—­æµ‹è¯•ä¿¡å· */
 101   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                            // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
 102   2                          ADC_BIAS_EN(0x1) |                           // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 103   2                          ADC_BIAS_SEL(0x1);                           // åç½®ç”µæµï¼š1x
 104   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) |                       // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P1
             -3ï¼‰
 105   2                         ADC_EXT_SEL(0x0);                             // é€‰æ‹©å¤–éƒ¨é€šé“
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 3   

 106   2      
 107   2              break;
 108   2          }
 109   1      
 110   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0è½¬æ¢
 111   1                      ADC_EN(0x1);        // ä½¿èƒ½A/Dè½¬æ¢
 112   1          delay_ms(1);                    // ç­‰å¾…ADCç¨³å®š
 113   1      }
 114          
 115          // adcå®Œæˆä¸€æ¬¡è½¬æ¢
 116          // è½¬æ¢å¥½çš„å€¼æ”¾å…¥å…¨å±€å˜é‡ adc0_val ä¸­
 117          // éœ€è¦æ³¨æ„ï¼Œè¿™æ¬¾èŠ¯ç‰‡çš„adcä¸èƒ½é¢‘ç¹é‡‡é›†ï¼Œéœ€è¦å»¶æ—¶ä¸€ä¸‹å†é‡‡é›†ä¸€æ¬¡
 118          // void adc_single_getval(void)
 119          // {
 120          //     ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 121          //     while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 122          //         ;                                             // ç­‰å¾…è½¬æ¢å®Œæˆ
 123          //     adc0_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å–channel0çš„å€¼
 124          //     ADC_STA = ADC_CHAN0_DONE(0x1);                    // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 125          // }
 126          
 127          // è·å–ä¸€æ¬¡adcé‡‡é›†+æ»¤æ³¢åçš„å€¼
 128          u16 adc_get_val(void)
 129          {
 130   1          u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 131   1          volatile u16 g_temp_value = 0;
 132   1          volatile u32 g_tmpbuff = 0;
 133   1          volatile u16 g_adcmax = 0;
 134   1          volatile u16 g_adcmin = 0xFFFF;
 135   1      
 136   1          // é‡‡é›†20æ¬¡ï¼Œå»æ‰å‰ä¸¤æ¬¡é‡‡æ ·ï¼Œå†å»æ‰ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼Œå†å–å¹³å‡å€¼
 137   1          for (i = 0; i < 20; i++)
 138   1          {
 139   2              ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 140   2              while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 141   2                  ;                                                 // ç­‰å¾…è½¬æ¢å®Œæˆ
 142   2              g_temp_value = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å– channel0 çš„å€¼
 143   2              ADC_STA = ADC_CHAN0_DONE(0x1);                        // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 144   2      
 145   2              if (i < 2)
 146   2                  continue; // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·çš„
 147   2              if (g_temp_value > g_adcmax)
 148   2                  g_adcmax = g_temp_value; // æœ€å¤§
 149   2              if (g_temp_value < g_adcmin)
 150   2                  g_adcmin = g_temp_value; // æœ€å°
 151   2      
 152   2              g_tmpbuff += g_temp_value;
 153   2          }
 154   1      
 155   1          g_tmpbuff -= g_adcmax;           // å»æ‰ä¸€ä¸ªæœ€å¤§
 156   1          g_tmpbuff -= g_adcmin;           // å»æ‰ä¸€ä¸ªæœ€å°
 157   1          g_temp_value = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 158   1      
 159   1          return g_temp_value;
 160   1      }
 161          
 162          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 163          u32 get_voltage_from_pin(void)
 164          {
 165   1          volatile u32 adc_aver_val = 0; // å­˜æ”¾adcæ»¤æ³¢åçš„å€¼
 166   1          // é‡‡é›†çƒ­æ•ç”µé˜»çš„ç”µå‹
 167   1          adc_aver_val = adc_get_val();
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 4   

 168   1      
 169   1          // 4095ï¼ˆadcè½¬æ¢åï¼Œå¯èƒ½å‡ºç°çš„æœ€å¤§çš„å€¼ï¼‰ * 0.0012 == 4.914ï¼Œçº¦ç­‰äº5Vï¼ˆVCCï¼‰
 170   1          return adc_aver_val * 12 / 10; // å‡è®¾æ˜¯4095ï¼Œ4095 * 12/10 == 4915mV
 171   1      }
 172          
 173          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 174          void temperature_scan(void)
 175          {
 176   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 177   1      
 178   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡30minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå
             -› ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 179   1          // if (TEMP_75_30MIN == temp_status)
 180   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 181   1          if (TEMP_75_5_MIN == temp_status)
 182   1          {
 183   2              return;
 184   2          }
 185   1      
 186   1          adc_sel_pin(ADC_SEL_PIN_GET_TEMP); // å…ˆåˆ‡æ¢æˆçƒ­æ•ç”µé˜»å¯¹åº”çš„å¼•è„šçš„adcé…ç½®
 187   1          voltage = get_voltage_from_pin();  // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 188   1      
 189   1      #if USE_MY_DEBUG
 190   1          // printf("PIN-8 voltage: %lu mV\n", voltage);
 191   1      #endif // USE_MY_DEBUG
 192   1      
 193   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 194   1          if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 195   1          {
 196   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 197   2      
 198   2              {
 199   3                  // æ£€æµ‹10æ¬¡ï¼Œå¦‚æœ10æ¬¡éƒ½å°äºè¿™ä¸ªç”µå‹å€¼ï¼Œæ‰è¯´æ˜æ¸©åº¦çœŸçš„å¤§äº75æ‘„æ°åº¦
 200   3                  u8 i = 0;
 201   3                  for (i = 0; i < 10; i++)
 202   3                  {
 203   4                      voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 204   4                      if (voltage > VOLTAGE_TEMP_75)
 205   4                      {
 206   5                          // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
 207   5                          temp_status = TEMP_NORMAL;
 208   5                          return;
 209   5                      }
 210   4                  }
 211   3      
 212   3                  // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜æ¸©åº¦ç¡®å®å¤§äº75æ‘„æ°åº¦
 213   3      #if USE_MY_DEBUG
 214   3      // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦\n");
 215   3      // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV", voltage);
 216   3      #endif
 217   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦
 218   3                  return;                // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 219   3              }
 220   2      
 221   2              // static u8 flag_adc_filter = 0;
 222   2              // flag_adc_filter <<= 1;
 223   2              // if (voltage > VOLTAGE_TEMP_75) // ç”µå‹å€¼å¤§äº75åº¦å¯¹åº”çš„ç”µå‹ï¼Œè¯´æ˜æ¸©åº¦å°äº75åº¦
 224   2              // {
 225   2              //     flag_adc_filter = 0;
 226   2              // }
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 5   

 227   2              // else
 228   2              // {
 229   2              //     flag_adc_filter |= 1;
 230   2              // }
 231   2      
 232   2              // if (flag_adc_filter == 0xFF)
 233   2              // {
 234   2              // }
 235   2          }
 236   1          else if (temp_status == TEMP_75)
 237   1          {
 238   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 239   2              static bit tmr1_is_open = 0;
 240   2      
 241   2              if (0 == tmr1_is_open)
 242   2              {
 243   3                  tmr1_is_open = 1;
 244   3                  tmr1_cnt = 0;
 245   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡30min
 246   3              }
 247   2      
 248   2              // while (1) // è¿™ä¸ªwhileå¾ªç¯ä¼šå½±å“åˆ°9è„šè°ƒèŠ‚16è„šç”µå‹çš„åŠŸèƒ½
 249   2              // {
 250   2      #if 0 // è¿™é‡Œçš„ä»£ç åœ¨å®¢æˆ·é‚£è¾¹åè€Œå‡ºç°é—®é¢˜ï¼Œè¶…è¿‡90æ‘„æ°åº¦ä¸”1ä¸ªå°æ—¶éƒ½æ²¡æœ‰å°†PWMé
             -™åˆ°25%ï¼Œ
                    // å¯èƒ½æ˜¯ç”¨æˆ·é‚£è¾¹çš„ç”µå‹æœ‰è·³å˜ï¼Œå¯¼è‡´è¿™é‡Œæ¸…ç©ºäº†å®šæ—¶å™¨è®¡æ•°
                          if (voltage > VOLTAGE_TEMP_75)
                          {
                              // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
                              temp_status = TEMP_75; // æ¸©åº¦æ ‡è®°ä¸ºè¶…è¿‡75æ‘„æ°åº¦ï¼Œä½†æ˜¯æ²¡æœ‰ç´¯è®¡30min
                              tmr1_disable();        // å…³é—­å®šæ—¶å™¨
                              tmr1_cnt = 0;          // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
              #if USE_MY_DEBUG
                              // printf("åœ¨æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦æ—¶ï¼Œæ£€æµ‹åˆ°æœ‰ä¸€æ¬¡æ¸©åº¦æ²¡æœ‰è¶…è¿‡75æ‘„æ°
             -åº¦\n");
                              // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV\n", voltage);
              #endif
                              return;
                          }
              #endif
 265   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†30minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 266   2              // if (tmr1_cnt >= (u32)TMR1_CNT_30_MINUTES)
 267   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 268   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 269   2              {
 270   3                  u8 i = 0;
 271   3      #if USE_MY_DEBUG
 272   3                  // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦ä¸”è¶…è¿‡äº†30min\n");
 273   3                  // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV\n", voltage);
 274   3      #endif
 275   3      
 276   3                  for (i = 0; i < 10; i++)
 277   3                  {
 278   4                      voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 279   4                      if (voltage > VOLTAGE_TEMP_75)
 280   4                      {
 281   5                          // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
 282   5                          temp_status = TEMP_75;
 283   5                          return;
 284   5                      }
 285   4                  }
 286   3      
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 6   

 287   3                  // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ä¸Šé¢è¿ç»­ã€å¤šæ¬¡æ£€æµ‹åˆ°çš„æ¸©åº¦éƒ½å¤§äº75æ‘„æ°åº¦
 288   3                  // temp_status = TEMP_75_30MIN;
 289   3                  temp_status = TEMP_75_5_MIN;
 290   3                  tmr1_disable(); // å…³é—­å®šæ—¶å™¨
 291   3                  tmr1_cnt = 0;   // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 292   3                  tmr1_is_open = 0;
 293   3                  return;
 294   3              }
 295   2              // }  // while(1)
 296   2          }
 297   1      }
 298          
 299          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 300          void set_duty(void)
 301          {
 302   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 303   1          if (TEMP_NORMAL == temp_status)
 304   1          {
 305   2              according_pin9_to_adjust_pwm();
 306   2      #if USE_MY_DEBUG
 307   2              // printf("cur duty: %d\n", c_duty);
 308   2      #endif
 309   2          }
 310   1          else if (TEMP_75 == temp_status)
 311   1          {
 312   2              // å¦‚æœæ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦ä¸”ç´¯è®¡10min
 313   2              // tmr0_disable(); // å…³é—­å®šæ—¶å™¨0ï¼Œä¸ä»¥9è„šçš„ç”µå‹æ¥è°ƒèŠ‚PWM
 314   2              // tmr0_is_open = 0;
 315   2              // è®¾å®šå ç©ºæ¯”
 316   2              // adjust_duty = PWM_DUTY_50_PERCENT;
 317   2      
 318   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 319   2              {
 320   3                  // æ˜¯å¦è¦æ›´æ–°æ‰€æœ‰pwmé€šé“å¾…è°ƒèŠ‚çš„å ç©ºæ¯”å€¼ï¼ˆæ¸©åº¦å¼‚å¸¸åï¼Œè¿™ä¸ªä»£ç å—ä
             -¹‹åæ‰§è¡Œä¸€æ¬¡ï¼‰
 321   3                  static bit flag_is_update_adjust_duty = 1;
 322   3                  if (flag_is_update_adjust_duty)
 323   3                  {
 324   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_0_duty);
 325   4                      adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_1_duty);
 326   4                      flag_is_update_adjust_duty = 0;
 327   4                  }
 328   3              }
 329   2          }
 330   1          // else if (TEMP_75_30MIN == temp_status)
 331   1          else if (TEMP_75_5_MIN == temp_status)
 332   1          {
 333   2              // tmr0_disable(); // å…³é—­å®šæ—¶å™¨0ï¼Œä¸ä»¥9è„šçš„ç”µå‹æ¥è°ƒèŠ‚PWM
 334   2              // tmr0_is_open = 0;
 335   2              // è®¾å®šå ç©ºæ¯”
 336   2              // adjust_duty = PWM_DUTY_25_PERCENT;
 337   2      
 338   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 339   2              {
 340   3                  // æ˜¯å¦è¦æ›´æ–°æ‰€æœ‰pwmé€šé“å¾…è°ƒèŠ‚çš„å ç©ºæ¯”å€¼ï¼ˆæ¸©åº¦å¼‚å¸¸åï¼Œè¿™ä¸ªä»£ç å—ä
             -¹‹åæ‰§è¡Œä¸€æ¬¡ï¼‰
 341   3                  static bit flag_is_update_adjust_duty = 1;
 342   3                  if (flag_is_update_adjust_duty)
 343   3                  {
 344   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_0_duty);
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 7   

 345   4                      adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_1_duty);
 346   4                      flag_is_update_adjust_duty = 0;
 347   4                  }
 348   3              }
 349   2          }
 350   1      }
 351          
 352          volatile u16 adc_val_pin_9 = 0; // å­˜æ”¾9è„šé‡‡é›†åˆ°çš„adå€¼
 353          // volatile u16 adc_val_pin_9_filter_count = 0;
 354          // u16 adc_val_pin_9_temp;
 355          // æ›´æ–°9è„šé‡‡é›†çš„adå€¼
 356          void adc_update_pin_9_adc_val(void)
 357          {
 358   1          adc_sel_pin(ADC_SEL_PIN_GET_VOL);
 359   1          adc_val_pin_9 = adc_get_val();
 360   1      
 361   1      #if USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 362   1          // printf("adc_val_pin_9 %u\n", adc_val_pin_9);
 363   1      
 364   1          // printf(",a=%u,", adc_val_pin_9);
 365   1      #endif // USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 366   1      }
 367          
 368          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
 369          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
 370          void fan_scan(void)
 371          {
 372   1          static u8 last_fan_status = FAN_STATUS_NORMAL;
 373   1      
 374   1          u16 adc_val = 0;
 375   1          adc_sel_pin(ADC_SEL_PIN_FAN_DETECT);
 376   1          adc_val = adc_get_val();
 377   1      
 378   1          // {
 379   1          //     static u16 cnt = 0;
 380   1          //     cnt++;
 381   1          //     if (cnt >= 200)
 382   1          //     {
 383   1          //         cnt = 0;
 384   1          //         printf("fan adc val : %u\n", adc_val);
 385   1          //     }
 386   1          // }
 387   1      
 388   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 389   1          {
 390   2              if (adc_val >= ADC_VAL_WHEN_FAN_ERR)
 391   2              {
 392   3                  flag_tim_scan_fan_is_err = 1;
 393   3              }
 394   2              else
 395   2              {
 396   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 397   3                  flag_tim_scan_fan_is_err = 0;
 398   3              }
 399   2      
 400   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 401   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 402   2      
 403   2              // å¦‚æœæ˜¯ä» é£æ‰‡å¼‚å¸¸å·¥ä½œ -> é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œæ‰ä¼šæ‰§è¡Œä¸‹é¢çš„è¯­å¥
 404   2              // é£æ‰‡å·¥ä½œæ­£å¸¸ä¹‹åï¼Œä¸‹é¢çš„è¯­å¥å¹¶ä¸èƒ½è®©å½“å‰pwmå ç©ºæ¯”æ¢å¤
C51 COMPILER V9.60.7.0   ADC                                                               06/07/2025 16:56:13 PAGE 8   

 405   2              // if (FAN_STATUS_ERROR == last_fan_status)
 406   2              // {
 407   2              //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_0_duty);
 408   2              //     adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_1_duty);
 409   2              //     last_fan_status = FAN_STATUS_NORMAL;
 410   2              // }
 411   2          }
 412   1          else // FAN_STATUS_ERROR == cur_fan_status
 413   1          {
 414   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 415   2              if (adc_val < ADC_VAL_WHEN_FAN_NORMAL)
 416   2              {
 417   3                  flag_tim_scan_fan_is_err = 0;
 418   3              }
 419   2      
 420   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 421   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 422   2      
 423   2              // å¦‚æœæ˜¯ä» é£æ‰‡æ­£å¸¸å·¥ä½œ -> é£æ‰‡å¼‚å¸¸å·¥ä½œï¼Œæ‰ä¼šæ‰§è¡Œä¸‹é¢çš„è¯­å¥
 424   2              // åˆ°äº†é£æ‰‡å¼‚å¸¸å·¥ä½œä¹‹åï¼Œç«‹åˆ»è®¾ç½®æ‰€æœ‰pwmé€šé“å¯ä»¥è°ƒèŠ‚çš„æœ€å¤§çš„å ç©ºæ¯”
 425   2              if (FAN_STATUS_NORMAL == last_fan_status)
 426   2              {
 427   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_0_duty);
 428   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_1_duty);
 429   3                  last_fan_status = FAN_STATUS_ERROR;
 430   3              }
 431   2          }
 432   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    920    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
