C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\R
                    -elease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          volatile bit flag_is_rf_enable = 0;      // æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½rfé¥æ§å™¨çš„åŠŸèƒ½
   4          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
   5          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
   6          
   7          // // å°†æŒ‰é”®é”®å€¼ä¸
   8          // static const u8 rf_key_map_table[][2] =
   9          // {
  10          
  11          // }
  12          
  13          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  14          enum RF_KEY_EVENT
  15          {
  16              RF_KEY_EVENT_NONE = 0,
  17              RF_KEY_EVENT_ID_1_CLICK,
  18              RF_KEY_EVENT_ID_1_LONG,
  19              RF_KEY_EVENT_ID_1_HOLD,
  20              RF_KEY_EVENT_ID_1_LOOSE,
  21          
  22              RF_KEY_EVENT_ID_2_CLICK,
  23              RF_KEY_EVENT_ID_2_LONG,
  24              RF_KEY_EVENT_ID_2_HOLD,
  25              RF_KEY_EVENT_ID_2_LOOSE,
  26          
  27              RF_KEY_EVENT_ID_3_CLICK,
  28              RF_KEY_EVENT_ID_3_LONG,
  29              RF_KEY_EVENT_ID_3_HOLD,
  30              RF_KEY_EVENT_ID_3_LOOSE,
  31          
  32              RF_KEY_EVENT_ID_4_CLICK,
  33              RF_KEY_EVENT_ID_4_LONG,
  34              RF_KEY_EVENT_ID_4_HOLD,
  35              RF_KEY_EVENT_ID_4_LOOSE,
  36          
  37              RF_KEY_EVENT_ID_5_CLICK,
  38              RF_KEY_EVENT_ID_5_LONG,
  39              RF_KEY_EVENT_ID_5_HOLD,
  40              RF_KEY_EVENT_ID_5_LOOSE,
  41          
  42              RF_KEY_EVENT_ID_6_CLICK,
  43              RF_KEY_EVENT_ID_6_LONG,
  44              RF_KEY_EVENT_ID_6_HOLD,
  45              RF_KEY_EVENT_ID_6_LOOSE,
  46          
  47              RF_KEY_EVENT_ID_7_CLICK,
  48              RF_KEY_EVENT_ID_7_LONG,
  49              RF_KEY_EVENT_ID_7_HOLD,
  50              RF_KEY_EVENT_ID_7_LOOSE,
  51          
  52              RF_KEY_EVENT_ID_8_CLICK,
  53              RF_KEY_EVENT_ID_8_LONG,
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 2   

  54              RF_KEY_EVENT_ID_8_HOLD,
  55              RF_KEY_EVENT_ID_8_LOOSE,
  56          
  57              RF_KEY_EVENT_ID_9_CLICK,
  58              RF_KEY_EVENT_ID_9_LONG,
  59              RF_KEY_EVENT_ID_9_HOLD,
  60              RF_KEY_EVENT_ID_9_LOOSE,
  61          
  62              RF_KEY_EVENT_ID_10_CLICK,
  63              RF_KEY_EVENT_ID_10_LONG,
  64              RF_KEY_EVENT_ID_10_HOLD,
  65              RF_KEY_EVENT_ID_10_LOOSE,
  66          
  67              RF_KEY_EVENT_ID_11_CLICK,
  68              RF_KEY_EVENT_ID_11_LONG,
  69              RF_KEY_EVENT_ID_11_HOLD,
  70              RF_KEY_EVENT_ID_11_LOOSE,
  71          
  72              RF_KEY_EVENT_ID_12_CLICK,
  73              RF_KEY_EVENT_ID_12_LONG,
  74              RF_KEY_EVENT_ID_12_HOLD,
  75              RF_KEY_EVENT_ID_12_LOOSE,
  76          };
  77          
  78          #define RF_KEY_EFFECT_EVENT_NUMS (4) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•° (å•å‡»ã€é•¿æŒ‰ã€æ
             -Œç»­ã€æ¾å¼€)
  79          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
  80          static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
  81              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
  82              {RF_KEY_ID_1, RF_KEY_EVENT_ID_1_CLICK, RF_KEY_EVENT_ID_1_LONG, RF_KEY_EVENT_ID_1_HOLD, RF_KEY_EVENT_ID
             -_1_LOOSE},      //
  83              {RF_KEY_ID_2, RF_KEY_EVENT_ID_2_CLICK, RF_KEY_EVENT_ID_2_LONG, RF_KEY_EVENT_ID_2_HOLD, RF_KEY_EVENT_ID
             -_2_LOOSE},      //
  84              {RF_KEY_ID_3, RF_KEY_EVENT_ID_3_CLICK, RF_KEY_EVENT_ID_3_LONG, RF_KEY_EVENT_ID_3_HOLD, RF_KEY_EVENT_ID
             -_3_LOOSE},      //
  85              {RF_KEY_ID_4, RF_KEY_EVENT_ID_4_CLICK, RF_KEY_EVENT_ID_4_LONG, RF_KEY_EVENT_ID_4_HOLD, RF_KEY_EVENT_ID
             -_4_LOOSE},      //
  86              {RF_KEY_ID_5, RF_KEY_EVENT_ID_5_CLICK, RF_KEY_EVENT_ID_5_LONG, RF_KEY_EVENT_ID_5_HOLD, RF_KEY_EVENT_ID
             -_5_LOOSE},      //
  87              {RF_KEY_ID_6, RF_KEY_EVENT_ID_6_CLICK, RF_KEY_EVENT_ID_6_LONG, RF_KEY_EVENT_ID_6_HOLD, RF_KEY_EVENT_ID
             -_6_LOOSE},      //
  88              {RF_KEY_ID_7, RF_KEY_EVENT_ID_7_CLICK, RF_KEY_EVENT_ID_7_LONG, RF_KEY_EVENT_ID_7_HOLD, RF_KEY_EVENT_ID
             -_7_LOOSE},      //
  89              {RF_KEY_ID_8, RF_KEY_EVENT_ID_8_CLICK, RF_KEY_EVENT_ID_8_LONG, RF_KEY_EVENT_ID_8_HOLD, RF_KEY_EVENT_ID
             -_8_LOOSE},      //
  90              {RF_KEY_ID_9, RF_KEY_EVENT_ID_9_CLICK, RF_KEY_EVENT_ID_9_LONG, RF_KEY_EVENT_ID_9_HOLD, RF_KEY_EVENT_ID
             -_9_LOOSE},      //
  91              {RF_KEY_ID_10, RF_KEY_EVENT_ID_10_CLICK, RF_KEY_EVENT_ID_10_LONG, RF_KEY_EVENT_ID_10_HOLD, RF_KEY_EVEN
             -T_ID_10_LOOSE}, //
  92              {RF_KEY_ID_11, RF_KEY_EVENT_ID_11_CLICK, RF_KEY_EVENT_ID_11_LONG, RF_KEY_EVENT_ID_11_HOLD, RF_KEY_EVEN
             -T_ID_11_LOOSE}, //
  93              {RF_KEY_ID_12, RF_KEY_EVENT_ID_12_CLICK, RF_KEY_EVENT_ID_12_LONG, RF_KEY_EVENT_ID_12_HOLD, RF_KEY_EVEN
             -T_ID_12_LOOSE}, //
  94          };
  95          
  96          extern u8 rf_key_get_key_id(void);
  97          volatile struct key_driver_para rf_key_para = {
  98              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
  99              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 100              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
 101              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 3   

             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
 102              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
 103              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 104              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 105              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 106              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
 107              // // .click_cnt = 0,
 108              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 109              // // .notify_value = 0,
 110              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
 111              // .get_value = ad_key_get_key_id,
 112          
 113              // .latest_key_val = AD_KEY_ID_NONE,
 114              // .latest_key_event = KEY_EVENT_NONE,
 115          
 116              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 117              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
 118              // NO_KEY,
 119              0, // .last_key
 120          
 121              0,                   // .filter_value
 122              0,                   // .filter_cnt
 123              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
 124          
 125              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
 126              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
 127              0,                                                                                              // .pr
             -ess_cnt
 128          
 129              0,                              // .click_cnt
 130              0,                              // .click_delay_cnt
 131              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
 132              // NO_KEY,
 133              0,                 // .notify_value
 134              KEY_TYPE_RF,       // .key_type
 135              rf_key_get_key_id, // .get_value
 136          
 137              RF_KEY_ID_NONE, // .latest_key_val
 138              KEY_EVENT_NONE, // .latest_key_event
 139          }; // volatile struct key_driver_para rf_key_para
 140          
 141          static u8 rf_key_get_key_id(void)
 142          {
 143   1          if (flag_is_recved_rf_data)
 144   1          {
 145   2              flag_is_recved_rf_data = 0;
 146   2              if (rf_data)
 147   2              {
 148   3                  u8 ret = (u8)rf_data;
 149   3                  rf_data = 0;
 150   3                  return (u8)ret; // ç›´æ¥è·å–é”®å€¼
 151   3              }
 152   2              else
 153   2              {
 154   3                  return NO_KEY;
 155   3              }
 156   2          }
 157   1          else
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 4   

 158   1          {
 159   2              return NO_KEY;
 160   2          }
 161   1      }
 162          
 163          /**
 164           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 165           *
 166           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 167           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 168           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_KEY_EVEN
             -T_NONE
 169           */
 170          static u8 __rf_key_get_event(const u8 key_val, const u8 key_event)
 171          {
 172   1          volatile u8 ret_key_event = RF_KEY_EVENT_NONE;
 173   1          u8 i = 0;
 174   1          for (; i < ARRAY_SIZE(rf_key_event_table); i++)
 175   1          {
 176   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 177   2              if (key_val == rf_key_event_table[i][0])
 178   2              {
 179   3                  ret_key_event = rf_key_event_table[i][key_event];
 180   3                  break;
 181   3              }
 182   2          }
 183   1      
 184   1          return ret_key_event;
 185   1      }
 186          
 187          void rf_key_handle(void)
 188          {
 189   1          u8 rf_key_event = RF_KEY_EVENT_NONE;
 190   1      
 191   1          if (rf_key_para.latest_key_val == RF_KEY_ID_NONE)
 192   1          {
 193   2              return;
 194   2          }
 195   1      
 196   1          rf_key_event = __rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 197   1          rf_key_para.latest_key_val = RF_KEY_ID_NONE;
 198   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 199   1      
 200   1          switch (rf_key_event)
 201   1          {
 202   2          case RF_KEY_EVENT_ID_1_CLICK:
 203   2      
 204   2              printf("key 1 click\n");
 205   2      
 206   2              break;
 207   2      
 208   2          case RF_KEY_EVENT_ID_2_CLICK:
 209   2      
 210   2              printf("key 2 click\n");
 211   2      
 212   2              break;
 213   2      
 214   2          case RF_KEY_EVENT_ID_3_CLICK:
 215   2      
 216   2              printf("key 3 click\n");
 217   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 5   

 218   2              break;
 219   2      
 220   2          case RF_KEY_EVENT_ID_4_CLICK:
 221   2      
 222   2              printf("key 4 click\n");
 223   2      
 224   2              break;
 225   2      
 226   2          case RF_KEY_EVENT_ID_5_CLICK:
 227   2      
 228   2              printf("key 5 click\n");
 229   2      
 230   2              break;
 231   2      
 232   2          case RF_KEY_EVENT_ID_6_CLICK:
 233   2      
 234   2              printf("key 6 click\n");
 235   2      
 236   2              break;
 237   2      
 238   2          case RF_KEY_EVENT_ID_7_CLICK:
 239   2      
 240   2              printf("key 7 click\n");
 241   2      
 242   2              break;
 243   2      
 244   2          case RF_KEY_EVENT_ID_8_CLICK:
 245   2      
 246   2              printf("key 8 click\n");
 247   2      
 248   2              break;
 249   2      
 250   2          case RF_KEY_EVENT_ID_9_CLICK:
 251   2      
 252   2              printf("key 9 click\n");
 253   2      
 254   2              break;
 255   2      
 256   2          case RF_KEY_EVENT_ID_10_CLICK:
 257   2      
 258   2              printf("key 10 click\n");
 259   2              if (flag_is_pwm_channel_0_enable) // å¦‚æœå·²ç»å¼€æœº/ç”±é¥æ§å™¨å¼€æœº
 260   2              {
 261   3                  // c_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_duty * æ—‹é’®é™
             -åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 262   3                  adjust_duty = PWM_DUTY_50_PERCENT;
 263   3                  limited_adjust_pwm_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_du
             -ty * æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 264   3                  c_duty = limited_adjust_pwm_duty;
 265   3                  set_pwm_duty();
 266   3              }
 267   2      
 268   2              break;
 269   2      
 270   2          case RF_KEY_EVENT_ID_11_CLICK:
 271   2      
 272   2              printf("key 11 click\n");
 273   2      
 274   2              break;
 275   2      
 276   2          case RF_KEY_EVENT_ID_12_CLICK: // æ§åˆ¶ pwm_channel_0 å¼€å…³çš„æŒ‰é”®
 277   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 6   

 278   2              // printf("key 12 click\n");
 279   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 280   2              {
 281   3                  flag_is_pwm_channel_0_enable = 0; // ç¦æ­¢timer2è°ƒèŠ‚pwm
 282   3                  // limited_adjust_pwm_duty = 0;
 283   3                  adjust_duty = 0;
 284   3                  c_duty = 0;
 285   3                  pwm_channel_0_disable();
 286   3                  set_pwm_duty();
 287   3                  printf("pwm channel 0 is disable\n");
 288   3              }
 289   2              else // å¦‚æœPWMæœªä½¿èƒ½
 290   2              {
 291   3                  flag_is_pwm_channel_0_enable = 1; // å…è®¸timer2è°ƒèŠ‚pwm
 292   3                  adjust_duty = MAX_PWM_DUTY;
 293   3                  limited_adjust_pwm_duty = (u32)adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // adjust_du
             -ty * æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 294   3                  c_duty = limited_adjust_pwm_duty;
 295   3                  set_pwm_duty();
 296   3                  pwm_channel_0_enable();
 297   3                  printf("pwm channel 0 is enable\n");
 298   3              }
 299   2      
 300   2              break;
 301   2      
 302   2          case RF_KEY_EVENT_ID_12_HOLD:
 303   2      
 304   2              printf("key 12 hold\n");
 305   2      
 306   2              break;
 307   2      
 308   2          default:
 309   2              break;
 310   2          }
 311   1      }
 312          
 313          void rf_recv_init(void)
 314          {
 315   1      #if 1 // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
 316   1      
 317   1          P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
 318   1          P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 319   1      
 320   1      #endif // æµ‹è¯•æ—¶ä½¿ç”¨
 321   1      
 322   1          // æ£€æµ‹æœ‰æ— 433é¥æ§å™¨åŠŸèƒ½çš„å¼•è„šï¼š
 323   1          P1_PU |= GPIO_P11_PULL_UP(0x01);      // ä¸Šæ‹‰
 324   1          P1_MD0 &= ~(GPIO_P11_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 325   1      
 326   1          if (0 == RF_ENABLE_PIN) // æ£€æµ‹è„šæ¥äº†0Rç”µé˜»åˆ°GNDï¼Œè¯´æ˜æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 327   1          {
 328   2              flag_is_rf_enable = 1;
 329   2          }
 330   1          else // æ£€æµ‹è„šæœªæ¥0Rç”µé˜»ï¼Œè¯´æ˜æ²¡æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 331   1          {
 332   2              flag_is_rf_enable = 0;
 333   2          }
 334   1      
 335   1      MY_DEBUG:
 336   1          flag_is_rf_enable = 1; // æµ‹è¯•æ—¶ä½¿ç”¨
 337   1          // flag_is_rf_enable = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 338   1      }
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/04/2025 14:59:14 PAGE 7   

*** WARNING C280 IN LINE 335 OF ..\..\User\rf_recv.c: 'MY_DEBUG': unreferenced label


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    523    ----
   CONSTANT SIZE    =    209    ----
   XDATA SIZE       =     83       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
