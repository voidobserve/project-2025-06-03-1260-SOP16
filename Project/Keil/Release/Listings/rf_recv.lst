C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\Re
                    -lease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          volatile bit flag_is_rf_enable = 0;      // æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½rfé¥æ§å™¨çš„åŠŸèƒ½
   4          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
   5          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
   6          
   7          // // å°†æŒ‰é”®é”®å€¼ä¸
   8          // static const u8 rf_key_map_table[][2] =
   9          // {
  10          
  11          // }
  12          
  13          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  14          enum RF_KEY_EVENT
  15          {
  16              RF_KEY_EVENT_NONE = 0,
  17              RF_KEY_EVENT_ID_1_CLICK,
  18              RF_KEY_EVENT_ID_1_LONG,
  19              RF_KEY_EVENT_ID_1_HOLD,
  20              RF_KEY_EVENT_ID_1_LOOSE,
  21          
  22              RF_KEY_EVENT_ID_2_CLICK,
  23              RF_KEY_EVENT_ID_2_LONG,
  24              RF_KEY_EVENT_ID_2_HOLD,
  25              RF_KEY_EVENT_ID_2_LOOSE,
  26          
  27              RF_KEY_EVENT_ID_3_CLICK,
  28              RF_KEY_EVENT_ID_3_LONG,
  29              RF_KEY_EVENT_ID_3_HOLD,
  30              RF_KEY_EVENT_ID_3_LOOSE,
  31          
  32              RF_KEY_EVENT_ID_4_CLICK,
  33              RF_KEY_EVENT_ID_4_LONG,
  34              RF_KEY_EVENT_ID_4_HOLD,
  35              RF_KEY_EVENT_ID_4_LOOSE,
  36          
  37              RF_KEY_EVENT_ID_5_CLICK,
  38              RF_KEY_EVENT_ID_5_LONG,
  39              RF_KEY_EVENT_ID_5_HOLD,
  40              RF_KEY_EVENT_ID_5_LOOSE,
  41          
  42              RF_KEY_EVENT_ID_6_CLICK,
  43              RF_KEY_EVENT_ID_6_LONG,
  44              RF_KEY_EVENT_ID_6_HOLD,
  45              RF_KEY_EVENT_ID_6_LOOSE,
  46          
  47              RF_KEY_EVENT_ID_7_CLICK,
  48              RF_KEY_EVENT_ID_7_LONG,
  49              RF_KEY_EVENT_ID_7_HOLD,
  50              RF_KEY_EVENT_ID_7_LOOSE,
  51          
  52              RF_KEY_EVENT_ID_8_CLICK,
  53              RF_KEY_EVENT_ID_8_LONG,
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 2   

  54              RF_KEY_EVENT_ID_8_HOLD,
  55              RF_KEY_EVENT_ID_8_LOOSE,
  56          
  57              RF_KEY_EVENT_ID_9_CLICK,
  58              RF_KEY_EVENT_ID_9_LONG,
  59              RF_KEY_EVENT_ID_9_HOLD,
  60              RF_KEY_EVENT_ID_9_LOOSE,
  61          
  62              RF_KEY_EVENT_ID_10_CLICK,
  63              RF_KEY_EVENT_ID_10_LONG,
  64              RF_KEY_EVENT_ID_10_HOLD,
  65              RF_KEY_EVENT_ID_10_LOOSE,
  66          
  67              RF_KEY_EVENT_ID_11_CLICK,
  68              RF_KEY_EVENT_ID_11_LONG,
  69              RF_KEY_EVENT_ID_11_HOLD,
  70              RF_KEY_EVENT_ID_11_LOOSE,
  71          
  72              RF_KEY_EVENT_ID_12_CLICK,
  73              RF_KEY_EVENT_ID_12_LONG,
  74              RF_KEY_EVENT_ID_12_HOLD,
  75              RF_KEY_EVENT_ID_12_LOOSE,
  76          
  77          #if USE_MY_TEST_433_REMOTE
  78          
  79              // æµ‹è¯•æ—¶ä½¿ç”¨åˆ°çš„æŒ‰é”®äº‹ä»¶ï¼Œå®é™…ä¸ä½¿ç”¨
  80              RF_KEY_EVENT_ID_TEST_1_CLICK,
  81              RF_KEY_EVENT_ID_TEST_1_LONG,
  82              RF_KEY_EVENT_ID_TEST_1_HOLD,
  83              RF_KEY_EVENT_ID_TEST_1_LOOSE,
  84          
  85              RF_KEY_EVENT_ID_TEST_2_CLICK,
  86              RF_KEY_EVENT_ID_TEST_2_LONG,
  87              RF_KEY_EVENT_ID_TEST_2_HOLD,
  88              RF_KEY_EVENT_ID_TEST_2_LOOSE,
  89          
  90              RF_KEY_EVENT_ID_TEST_3_CLICK,
  91              RF_KEY_EVENT_ID_TEST_3_LONG,
  92              RF_KEY_EVENT_ID_TEST_3_HOLD,
  93              RF_KEY_EVENT_ID_TEST_3_LOOSE,
  94          
  95              RF_KEY_EVENT_ID_TEST_4_CLICK,
  96              RF_KEY_EVENT_ID_TEST_4_LONG,
  97              RF_KEY_EVENT_ID_TEST_4_HOLD,
  98              RF_KEY_EVENT_ID_TEST_4_LOOSE,
  99          
 100          #endif // #if USE_MY_TEST_433_REMOTE
 101          };
 102          
 103          #define RF_KEY_EFFECT_EVENT_NUMS (4) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•° (å•å‡»ã€é•¿æŒ‰ã€æ
             -Œç»­ã€æ¾å¼€)
 104          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
 105          static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
 106              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
 107              {RF_KEY_ID_1, RF_KEY_EVENT_ID_1_CLICK, RF_KEY_EVENT_ID_1_LONG, RF_KEY_EVENT_ID_1_HOLD, RF_KEY_EVENT_ID
             -_1_LOOSE},      //
 108              {RF_KEY_ID_2, RF_KEY_EVENT_ID_2_CLICK, RF_KEY_EVENT_ID_2_LONG, RF_KEY_EVENT_ID_2_HOLD, RF_KEY_EVENT_ID
             -_2_LOOSE},      //
 109              {RF_KEY_ID_3, RF_KEY_EVENT_ID_3_CLICK, RF_KEY_EVENT_ID_3_LONG, RF_KEY_EVENT_ID_3_HOLD, RF_KEY_EVENT_ID
             -_3_LOOSE},      //
 110              {RF_KEY_ID_4, RF_KEY_EVENT_ID_4_CLICK, RF_KEY_EVENT_ID_4_LONG, RF_KEY_EVENT_ID_4_HOLD, RF_KEY_EVENT_ID
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 3   

             -_4_LOOSE},      //
 111              {RF_KEY_ID_5, RF_KEY_EVENT_ID_5_CLICK, RF_KEY_EVENT_ID_5_LONG, RF_KEY_EVENT_ID_5_HOLD, RF_KEY_EVENT_ID
             -_5_LOOSE},      //
 112              {RF_KEY_ID_6, RF_KEY_EVENT_ID_6_CLICK, RF_KEY_EVENT_ID_6_LONG, RF_KEY_EVENT_ID_6_HOLD, RF_KEY_EVENT_ID
             -_6_LOOSE},      //
 113              {RF_KEY_ID_7, RF_KEY_EVENT_ID_7_CLICK, RF_KEY_EVENT_ID_7_LONG, RF_KEY_EVENT_ID_7_HOLD, RF_KEY_EVENT_ID
             -_7_LOOSE},      //
 114              {RF_KEY_ID_8, RF_KEY_EVENT_ID_8_CLICK, RF_KEY_EVENT_ID_8_LONG, RF_KEY_EVENT_ID_8_HOLD, RF_KEY_EVENT_ID
             -_8_LOOSE},      //
 115              {RF_KEY_ID_9, RF_KEY_EVENT_ID_9_CLICK, RF_KEY_EVENT_ID_9_LONG, RF_KEY_EVENT_ID_9_HOLD, RF_KEY_EVENT_ID
             -_9_LOOSE},      //
 116              {RF_KEY_ID_10, RF_KEY_EVENT_ID_10_CLICK, RF_KEY_EVENT_ID_10_LONG, RF_KEY_EVENT_ID_10_HOLD, RF_KEY_EVEN
             -T_ID_10_LOOSE}, //
 117              {RF_KEY_ID_11, RF_KEY_EVENT_ID_11_CLICK, RF_KEY_EVENT_ID_11_LONG, RF_KEY_EVENT_ID_11_HOLD, RF_KEY_EVEN
             -T_ID_11_LOOSE}, //
 118              {RF_KEY_ID_12, RF_KEY_EVENT_ID_12_CLICK, RF_KEY_EVENT_ID_12_LONG, RF_KEY_EVENT_ID_12_HOLD, RF_KEY_EVEN
             -T_ID_12_LOOSE}, //
 119          
 120          #if USE_MY_TEST_433_REMOTE
 121          
 122              {RF_KEY_ID_TEST_1, RF_KEY_EVENT_ID_TEST_1_CLICK, RF_KEY_EVENT_ID_TEST_1_LONG, RF_KEY_EVENT_ID_TEST_1_H
             -OLD, RF_KEY_EVENT_ID_TEST_1_LOOSE}, //
 123              {RF_KEY_ID_TEST_2, RF_KEY_EVENT_ID_TEST_2_CLICK, RF_KEY_EVENT_ID_TEST_2_LONG, RF_KEY_EVENT_ID_TEST_2_H
             -OLD, RF_KEY_EVENT_ID_TEST_2_LOOSE}, //
 124              {RF_KEY_ID_TEST_3, RF_KEY_EVENT_ID_TEST_3_CLICK, RF_KEY_EVENT_ID_TEST_3_LONG, RF_KEY_EVENT_ID_TEST_3_H
             -OLD, RF_KEY_EVENT_ID_TEST_3_LOOSE}, //
 125              {RF_KEY_ID_TEST_4, RF_KEY_EVENT_ID_TEST_4_CLICK, RF_KEY_EVENT_ID_TEST_4_LONG, RF_KEY_EVENT_ID_TEST_4_H
             -OLD, RF_KEY_EVENT_ID_TEST_4_LOOSE}, //
 126          
 127          #endif // #if USE_MY_TEST_433_REMOTE
 128          };
 129          
 130          extern u8 rf_key_get_key_id(void);
 131          volatile struct key_driver_para rf_key_para = {
 132              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
 133              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 134              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
 135              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
 136              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
 137              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 138              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 139              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 140              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
 141              // // .click_cnt = 0,
 142              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 143              // // .notify_value = 0,
 144              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
 145              // .get_value = ad_key_get_key_id,
 146          
 147              // .latest_key_val = AD_KEY_ID_NONE,
 148              // .latest_key_event = KEY_EVENT_NONE,
 149          
 150              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 151              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
 152              // NO_KEY,
 153              0, // .last_key
 154          
 155              0,                   // .filter_value
 156              0,                   // .filter_cnt
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 4   

 157              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
 158          
 159              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
 160              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
 161              0,                                                                                              // .pr
             -ess_cnt
 162          
 163              0,                              // .click_cnt
 164              0,                              // .click_delay_cnt
 165              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
 166              // NO_KEY,
 167              0,                 // .notify_value
 168              KEY_TYPE_RF,       // .key_type
 169              rf_key_get_key_id, // .get_value
 170          
 171              RF_KEY_ID_NONE, // .latest_key_val
 172              KEY_EVENT_NONE, // .latest_key_event
 173          }; // volatile struct key_driver_para rf_key_para
 174          
 175          static u8 rf_key_get_key_id(void)
 176          {
 177   1          if (flag_is_recved_rf_data)
 178   1          {
 179   2              flag_is_recved_rf_data = 0;
 180   2              if (rf_data)
 181   2              {
 182   3                  u8 ret = (u8)rf_data;
 183   3                  rf_data = 0;
 184   3                  return (u8)ret; // ç›´æ¥è·å–é”®å€¼
 185   3              }
 186   2              else
 187   2              {
 188   3                  return NO_KEY;
 189   3              }
 190   2          }
 191   1          else
 192   1          {
 193   2              return NO_KEY;
 194   2          }
 195   1      }
 196          
 197          /**
 198           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 199           *
 200           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 201           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 202           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_KEY_EVEN
             -T_NONE
 203           */
 204          static u8 __rf_key_get_event(const u8 key_val, const u8 key_event)
 205          {
 206   1          volatile u8 ret_key_event = RF_KEY_EVENT_NONE;
 207   1          u8 i = 0;
 208   1          for (; i < ARRAY_SIZE(rf_key_event_table); i++)
 209   1          {
 210   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 211   2              if (key_val == rf_key_event_table[i][0])
 212   2              {
 213   3                  ret_key_event = rf_key_event_table[i][key_event];
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 5   

 214   3                  break;
 215   3              }
 216   2          }
 217   1      
 218   1          return ret_key_event;
 219   1      }
 220          
 221          void rf_key_handle(void)
 222          {
 223   1          u8 rf_key_event = RF_KEY_EVENT_NONE;
 224   1      
 225   1          if (rf_key_para.latest_key_val == RF_KEY_ID_NONE)
 226   1          {
 227   2              return;
 228   2          }
 229   1      
 230   1          // å¯èƒ½è¦åœ¨è¿™é‡Œè¯»å– rf_key_para.latest_key_event
 231   1          // çœ‹çœ‹æ˜¯ä¸æ˜¯ HOLDï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡é•¿æŒ‰ï¼Œç´¯è®¡å‡ æ¬¡åè¿›è¡Œå¯¹ç æ“ä½œ
 232   1          { // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 233   2              static u16 hold_cnt;
 234   2              static u8 last_key_val;
 235   2      
 236   2              if (last_key_val == rf_key_para.latest_key_val)
 237   2              {
 238   3                  if (rf_key_para.latest_key_event == KEY_EVENT_HOLD)
 239   3                  {
 240   4                      if (hold_cnt < 65535)
 241   4                      {
 242   5                          hold_cnt++;
 243   5      
 244   5                          // if (hold_cnt å¤§äºæŸä¸ªé˜ˆå€¼)
 245   5                          {
 246   6                              // å­˜æ”¾å¯¹ç çš„åœ°å€
 247   6                          }
 248   5                      }
 249   4                  }
 250   3              }
 251   2          } // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 252   1      
 253   1          rf_key_event = __rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 254   1          rf_key_para.latest_key_val = RF_KEY_ID_NONE;
 255   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 256   1      
 257   1          switch (rf_key_event)
 258   1          {
 259   2          case RF_KEY_EVENT_ID_1_CLICK: // ON/OFF
 260   2      
 261   2              // printf("key 1 click\n");
 262   2      
 263   2              // åªè¦æœ‰ä¸€è·¯å¼€å¯ï¼Œä¾¿è®¤ä¸ºç¯å…‰å·²ç»æ‰“å¼€ï¼š
 264   2              if (get_pwm_channel_0_status() || get_pwm_channel_1_status())
 265   2              {
 266   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 267   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(0);
 268   3      
 269   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 270   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 271   3      
 272   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 273   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 274   3      
 275   3                  pwm_channel_0_disable();
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 6   

 276   3                  pwm_channel_1_disable();
 277   3      
 278   3                  // printf("all pwm channels are disable\n");
 279   3              }
 280   2              else
 281   2              {
 282   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 283   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 284   3                  // adjust_pwm_channel_1_duty = adjust_pwm_channel_0_duty;
 285   3      
 286   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 287   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 288   3      
 289   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 290   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 291   3      
 292   3                  pwm_channel_0_enable();
 293   3                  pwm_channel_1_enable();
 294   3      
 295   3                  // printf("all pwm channels are enable\n");
 296   3              }
 297   2      
 298   2              break;
 299   2      
 300   2          case RF_KEY_EVENT_ID_2_CLICK: // 1+2æŒ‰é”®ï¼Œäº®åº¦è®¾ç½®ä¸º100%
 301   2      
 302   2              // printf("key 2 click\n");
 303   2              // åªè¦æœ‰ä¸€è·¯å¼€å¯ï¼Œä¾¿è®¤ä¸ºç¯å…‰å·²ç»æ‰“å¼€ï¼š
 304   2              if (get_pwm_channel_0_status() || get_pwm_channel_1_status())
 305   2              {
 306   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 307   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 308   3      
 309   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 310   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 311   3      
 312   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 313   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 314   3              }
 315   2      
 316   2              break;
 317   2      
 318   2          case RF_KEY_EVENT_ID_3_CLICK: // pwm_channel_0 duty++
 319   2      
 320   2              // printf("key 3 click\n");
 321   2      
 322   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 323   2              {
 324   3                  u16 expected_pwm_duty = adjust_pwm_channel_0_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 325   3      
 326   3                  if (adjust_pwm_channel_0_duty < PWM_DUTY_100_PERCENT)
 327   3                  {
 328   4                      // expected_pwm_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 329   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 330   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 331   4                  }
 332   3              }
 333   2      
 334   2              break;
 335   2      
 336   2          case RF_KEY_EVENT_ID_4_CLICK: // pwm_channel_1 duty++
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 7   

 337   2      
 338   2              // printf("key 4 click\n");
 339   2      
 340   2              if (get_pwm_channel_1_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 341   2              {
 342   3                  u16 expected_pwm_duty = adjust_pwm_channel_1_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 343   3      
 344   3                  if (adjust_pwm_channel_1_duty < PWM_DUTY_100_PERCENT)
 345   3                  {
 346   4                      // expected_pwm_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 347   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 348   4                      adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 349   4                  }
 350   3              }
 351   2      
 352   2              break;
 353   2      
 354   2          case RF_KEY_EVENT_ID_5_CLICK: // set pwm_channel_0 50%
 355   2      
 356   2              // printf("key 5 click\n");
 357   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 358   2              {
 359   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 360   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 361   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 362   3              }
 363   2      
 364   2              break;
 365   2      
 366   2          case RF_KEY_EVENT_ID_6_CLICK: // set pwm_channel_1 50%
 367   2      
 368   2              // printf("key 6 click\n");
 369   2              if (get_pwm_channel_1_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 370   2              {
 371   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 372   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 373   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 374   3              }
 375   2      
 376   2              break;
 377   2      
 378   2          case RF_KEY_EVENT_ID_7_CLICK: // pwm_channel_0 duty--
 379   2      
 380   2              // printf("key 7 click\n");
 381   2      
 382   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 383   2              {
 384   3                  u16 expected_pwm_duty = adjust_pwm_channel_0_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 385   3      
 386   3                  if (adjust_pwm_channel_0_duty > (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©ºæ¯”å
             -¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 387   3                  {
 388   4                      // expected_pwm_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 389   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 390   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 391   4                  }
 392   3              }
 393   2      
 394   2              break;
 395   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 8   

 396   2          case RF_KEY_EVENT_ID_8_CLICK: // pwm_channel_1 duty--
 397   2      
 398   2              // printf("key 8 click\n");
 399   2      
 400   2              if (get_pwm_channel_1_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 401   2              {
 402   3                  u16 expected_pwm_duty = adjust_pwm_channel_1_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 403   3      
 404   3                  if (adjust_pwm_channel_1_duty > (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©ºæ¯”å
             -¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 405   3                  {
 406   4                      // expected_pwm_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 407   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 408   4                      adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 409   4                  }
 410   3              }
 411   2      
 412   2              break;
 413   2      
 414   2          case RF_KEY_EVENT_ID_9_CLICK: // åŠ å¤§PWMå ç©ºæ¯”
 415   2      
 416   2              printf("key 9 click\n");
 417   2      
 418   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 419   2              {
 420   3                  // u16 expected_pwm_duty = cur_pwm_channel_0_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 421   3      
 422   3                  // if (cur_pwm_channel_0_duty < PWM_DUTY_100_PERCENT)
 423   3                  // {
 424   3                  //     expected_pwm_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 425   3                  //     cur_pwm_channel_0_duty = get_pwm_channel_0_adjust_duty(expected_pwm_duty);
 426   3                  //     set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 427   3                  // }
 428   3      
 429   3                  u16 expected_pwm_duty = adjust_pwm_channel_0_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 430   3      
 431   3                  if (adjust_pwm_channel_0_duty < PWM_DUTY_100_PERCENT)
 432   3                  {
 433   4                      // expected_pwm_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 434   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 435   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 436   4                  }
 437   3              }
 438   2      
 439   2              break;
 440   2      
 441   2          case RF_KEY_EVENT_ID_10_CLICK: // è®¾ç½®å ç©ºæ¯”ä¸º50%
 442   2      
 443   2              // printf("key 10 click\n");
 444   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 445   2              {
 446   3                  // cur_pwm_channel_0_duty = get_pwm_channel_0_adjust_duty(PWM_DUTY_50_PERCENT);
 447   3                  // set_pwm_channel_0_duty(cur_pwm_channel_0_duty);
 448   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 449   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 450   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 451   3              }
 452   2      
 453   2              break;
 454   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 9   

 455   2          case RF_KEY_EVENT_ID_11_CLICK: // å‡å°PWMå ç©ºæ¯”
 456   2      
 457   2              // printf("key 11 click\n");
 458   2      
 459   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 460   2              {
 461   3      
 462   3                  u16 expected_pwm_duty = adjust_pwm_channel_0_duty; // å­˜æ”¾æœŸæœ›è®¾å®šçš„pwmå ç©ºæ¯”
 463   3      
 464   3                  if (adjust_pwm_channel_0_duty > (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©ºæ¯”å
             -¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 465   3                  {
 466   4                      // expected_pwm_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 467   4                      expected_pwm_duty += (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä»¥æ—‹é’®é™åˆ¶
             -çš„å ç©ºæ¯”ä¸º100%ï¼‰
 468   4                      adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expected_pwm_duty);
 469   4                      // set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 470   4                  }
 471   3              }
 472   2      
 473   2              break;
 474   2      
 475   2          case RF_KEY_EVENT_ID_12_CLICK: // æ§åˆ¶ pwm_channel_0 å¼€å…³çš„æŒ‰é”®
 476   2      
 477   2              // printf("key 12 click\n");
 478   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 479   2              {
 480   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 481   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 482   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 483   3                  pwm_channel_0_disable();
 484   3                  // printf("pwm channel 0 is disable\n");
 485   3              }
 486   2              else // å¦‚æœPWMæœªä½¿èƒ½
 487   2              {
 488   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 489   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 490   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 491   3                  pwm_channel_0_enable();
 492   3                  // printf("pwm channel 0 is enable\n");
 493   3              }
 494   2      
 495   2              break;
 496   2      
 497   2          case RF_KEY_EVENT_ID_12_HOLD:
 498   2      
 499   2              // printf("key 12 hold\n");
 500   2      
 501   2              break;
 502   2      
 503   2      #if USE_MY_TEST_433_REMOTE
 504   2      
 505   2          case RF_KEY_EVENT_ID_TEST_1_CLICK:
 506   2      
 507   2              printf("test 1 click\n");
 508   2              if (limited_max_pwm_duty < (MAX_PWM_DUTY - 500))
 509   2              {
 510   3                  limited_max_pwm_duty += 500;
 511   3              }
 512   2      
 513   2              break;
 514   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 10  

 515   2          case RF_KEY_EVENT_ID_TEST_2_CLICK:
 516   2      
 517   2              printf("test 2 click\n");
 518   2      
 519   2              if (limited_max_pwm_duty > (0 + 500))
 520   2              {
 521   3                  limited_max_pwm_duty -= 500;
 522   3              }
 523   2      
 524   2              break;
 525   2      
 526   2          case RF_KEY_EVENT_ID_TEST_3_CLICK:
 527   2      
 528   2              printf("test 3 click\n");
 529   2      
 530   2              break;
 531   2      
 532   2          case RF_KEY_EVENT_ID_TEST_4_CLICK:
 533   2      
 534   2              printf("test 4 click\n");
 535   2      
 536   2              break;
 537   2      
 538   2      #endif // #if USE_MY_TEST_433_REMOTE
 539   2      
 540   2          default:
 541   2              break;
 542   2          }
 543   1      }
 544          
 545          void rf_recv_init(void)
 546          {
 547   1      // MY_DEBUG:
 548   1      #if USE_MY_TEST_PIN // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
 549   1      
 550   1          P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
 551   1          P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 552   1      
 553   1      #else // å®é™…ç”¨åˆ°çš„ã€éæµ‹è¯•æ—¶ä½¿ç”¨çš„rfä¿¡å·æ£€æµ‹å¼•è„šï¼š
              
                  P0_PU |= GPIO_P03_PULL_UP(0x01);      // ä¸Šæ‹‰
                  P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
              
              #endif // #if USE_MY_TEST_PIN
 559   1      
 560   1          // æ£€æµ‹æœ‰æ— 433é¥æ§å™¨åŠŸèƒ½çš„å¼•è„šï¼š
 561   1          P1_PU |= GPIO_P11_PULL_UP(0x01);      // ä¸Šæ‹‰
 562   1          P1_MD0 &= ~(GPIO_P11_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 563   1      
 564   1          if (0 == RF_ENABLE_PIN) // æ£€æµ‹è„šæ¥äº†0Rç”µé˜»åˆ°GNDï¼Œè¯´æ˜æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 565   1          {
 566   2              flag_is_rf_enable = 1;
 567   2          }
 568   1          else // æ£€æµ‹è„šæœªæ¥0Rç”µé˜»ï¼Œè¯´æ˜æ²¡æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 569   1          {
 570   2              flag_is_rf_enable = 0;
 571   2          }
 572   1      
 573   1          // MY_DEBUG:
 574   1          flag_is_rf_enable = 1; // æµ‹è¯•æ—¶ä½¿ç”¨ï¼ˆä½¿èƒ½433é¥æ§çš„åŠŸèƒ½ï¼‰
 575   1          // flag_is_rf_enable = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 576   1      }
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/07/2025 16:56:14 PAGE 11  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1042    ----
   CONSTANT SIZE    =     69    ----
   XDATA SIZE       =    108       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
