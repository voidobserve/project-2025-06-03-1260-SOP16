C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECV
OBJECT MODULE PLACED IN .\Release\Objects\rf_recv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_recv.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INC
                    -DIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_recv.lst) OBJECT(.\Re
                    -lease\Objects\rf_recv.obj)

line level    source

   1          #include "rf_recv.h"
   2          
   3          // æ ‡å¿—ä½ï¼Œæ˜¯å¦å¤„äºrfå¯¹ç æ¨¡å¼
   4          // 0--æœªå¤„äº
   5          // 1--æ­£åœ¨å¯¹ç ï¼Œç­‰å¾…æŒ‰é”®é•¿æŒ‰
   6          // 2--å·²ç»å¯¹å®Œç ï¼Œç­‰å¾…æŒ‰é”®æ¾æ‰‹
   7          volatile u8 flag_is_in_rf_learning = 0;
   8          
   9          // rfå¯¹ç æœŸé—´ï¼Œç”¨äºä¸´æ—¶å­˜æ”¾é¥æ§å™¨åœ°å€çš„å˜é‡
  10          // åœ¨ rf_key_get_key_id() å‡½æ•°ä¸­å–å¾—ï¼Œå¦‚æœå¯¹ç æˆåŠŸï¼Œåˆ™ç›´æ¥åº”ç”¨è¯¥åœ°å€ï¼Œå†™å…¥flash
  11          volatile u16 tmp_rf_addr;
  12          rf_remote_info_t rf_remote_info = {0};
  13          
  14          volatile bit flag_is_rf_enable = 0;      // æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½rfé¥æ§å™¨çš„åŠŸèƒ½
  15          volatile bit flag_is_recved_rf_data = 0; // æ˜¯å¦æ¥æ”¶åˆ°äº†rfä¿¡å·
  16          volatile u32 rf_data = 0;                // å­˜æ”¾æ¥æ”¶åˆ°çš„rfæ•°æ®
  17          
  18          // // å°†æŒ‰é”®é”®å€¼ä¸
  19          // static const u8 rf_key_map_table[][2] =
  20          // {
  21          
  22          // }
  23          
  24          // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
  25          enum RF_KEY_EVENT
  26          {
  27              RF_KEY_EVENT_NONE = 0,
  28              RF_KEY_EVENT_ID_1_CLICK,
  29              RF_KEY_EVENT_ID_1_LONG,
  30              RF_KEY_EVENT_ID_1_HOLD,
  31              RF_KEY_EVENT_ID_1_LOOSE,
  32          
  33              RF_KEY_EVENT_ID_2_CLICK,
  34              RF_KEY_EVENT_ID_2_LONG,
  35              RF_KEY_EVENT_ID_2_HOLD,
  36              RF_KEY_EVENT_ID_2_LOOSE,
  37          
  38              RF_KEY_EVENT_ID_3_CLICK,
  39              RF_KEY_EVENT_ID_3_LONG,
  40              RF_KEY_EVENT_ID_3_HOLD,
  41              RF_KEY_EVENT_ID_3_LOOSE,
  42          
  43              RF_KEY_EVENT_ID_4_CLICK,
  44              RF_KEY_EVENT_ID_4_LONG,
  45              RF_KEY_EVENT_ID_4_HOLD,
  46              RF_KEY_EVENT_ID_4_LOOSE,
  47          
  48              RF_KEY_EVENT_ID_5_CLICK,
  49              RF_KEY_EVENT_ID_5_LONG,
  50              RF_KEY_EVENT_ID_5_HOLD,
  51              RF_KEY_EVENT_ID_5_LOOSE,
  52          
  53              RF_KEY_EVENT_ID_6_CLICK,
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 2   

  54              RF_KEY_EVENT_ID_6_LONG,
  55              RF_KEY_EVENT_ID_6_HOLD,
  56              RF_KEY_EVENT_ID_6_LOOSE,
  57          
  58              RF_KEY_EVENT_ID_7_CLICK,
  59              RF_KEY_EVENT_ID_7_LONG,
  60              RF_KEY_EVENT_ID_7_HOLD,
  61              RF_KEY_EVENT_ID_7_LOOSE,
  62          
  63              RF_KEY_EVENT_ID_8_CLICK,
  64              RF_KEY_EVENT_ID_8_LONG,
  65              RF_KEY_EVENT_ID_8_HOLD,
  66              RF_KEY_EVENT_ID_8_LOOSE,
  67          
  68              RF_KEY_EVENT_ID_9_CLICK,
  69              RF_KEY_EVENT_ID_9_LONG,
  70              RF_KEY_EVENT_ID_9_HOLD,
  71              RF_KEY_EVENT_ID_9_LOOSE,
  72          
  73              RF_KEY_EVENT_ID_10_CLICK,
  74              RF_KEY_EVENT_ID_10_LONG,
  75              RF_KEY_EVENT_ID_10_HOLD,
  76              RF_KEY_EVENT_ID_10_LOOSE,
  77          
  78              RF_KEY_EVENT_ID_11_CLICK,
  79              RF_KEY_EVENT_ID_11_LONG,
  80              RF_KEY_EVENT_ID_11_HOLD,
  81              RF_KEY_EVENT_ID_11_LOOSE,
  82          
  83              RF_KEY_EVENT_ID_12_CLICK,
  84              RF_KEY_EVENT_ID_12_LONG,
  85              RF_KEY_EVENT_ID_12_HOLD,
  86              RF_KEY_EVENT_ID_12_LOOSE,
  87          
  88          #if USE_MY_TEST_433_REMOTE
              
                  // æµ‹è¯•æ—¶ä½¿ç”¨åˆ°çš„æŒ‰é”®äº‹ä»¶ï¼Œå®é™…ä¸ä½¿ç”¨
                  RF_KEY_EVENT_ID_TEST_1_CLICK,
                  RF_KEY_EVENT_ID_TEST_1_LONG,
                  RF_KEY_EVENT_ID_TEST_1_HOLD,
                  RF_KEY_EVENT_ID_TEST_1_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_2_CLICK,
                  RF_KEY_EVENT_ID_TEST_2_LONG,
                  RF_KEY_EVENT_ID_TEST_2_HOLD,
                  RF_KEY_EVENT_ID_TEST_2_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_3_CLICK,
                  RF_KEY_EVENT_ID_TEST_3_LONG,
                  RF_KEY_EVENT_ID_TEST_3_HOLD,
                  RF_KEY_EVENT_ID_TEST_3_LOOSE,
              
                  RF_KEY_EVENT_ID_TEST_4_CLICK,
                  RF_KEY_EVENT_ID_TEST_4_LONG,
                  RF_KEY_EVENT_ID_TEST_4_HOLD,
                  RF_KEY_EVENT_ID_TEST_4_LOOSE,
              
              #endif // #if USE_MY_TEST_433_REMOTE
 112          };
 113          
 114          #define RF_KEY_EFFECT_EVENT_NUMS (4) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•° (å•å‡»ã€é•¿æŒ‰ã€æ
             -Œç»­ã€æ¾å¼€)
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 3   

 115          // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
 116          static const u8 rf_key_event_table[][RF_KEY_EFFECT_EVENT_NUMS + 1] = {
 117              // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
 118              {RF_KEY_ID_1, RF_KEY_EVENT_ID_1_CLICK, RF_KEY_EVENT_ID_1_LONG, RF_KEY_EVENT_ID_1_HOLD, RF_KEY_EVENT_ID
             -_1_LOOSE},      //
 119              {RF_KEY_ID_2, RF_KEY_EVENT_ID_2_CLICK, RF_KEY_EVENT_ID_2_LONG, RF_KEY_EVENT_ID_2_HOLD, RF_KEY_EVENT_ID
             -_2_LOOSE},      //
 120              {RF_KEY_ID_3, RF_KEY_EVENT_ID_3_CLICK, RF_KEY_EVENT_ID_3_LONG, RF_KEY_EVENT_ID_3_HOLD, RF_KEY_EVENT_ID
             -_3_LOOSE},      //
 121              {RF_KEY_ID_4, RF_KEY_EVENT_ID_4_CLICK, RF_KEY_EVENT_ID_4_LONG, RF_KEY_EVENT_ID_4_HOLD, RF_KEY_EVENT_ID
             -_4_LOOSE},      //
 122              {RF_KEY_ID_5, RF_KEY_EVENT_ID_5_CLICK, RF_KEY_EVENT_ID_5_LONG, RF_KEY_EVENT_ID_5_HOLD, RF_KEY_EVENT_ID
             -_5_LOOSE},      //
 123              {RF_KEY_ID_6, RF_KEY_EVENT_ID_6_CLICK, RF_KEY_EVENT_ID_6_LONG, RF_KEY_EVENT_ID_6_HOLD, RF_KEY_EVENT_ID
             -_6_LOOSE},      //
 124              {RF_KEY_ID_7, RF_KEY_EVENT_ID_7_CLICK, RF_KEY_EVENT_ID_7_LONG, RF_KEY_EVENT_ID_7_HOLD, RF_KEY_EVENT_ID
             -_7_LOOSE},      //
 125              {RF_KEY_ID_8, RF_KEY_EVENT_ID_8_CLICK, RF_KEY_EVENT_ID_8_LONG, RF_KEY_EVENT_ID_8_HOLD, RF_KEY_EVENT_ID
             -_8_LOOSE},      //
 126              {RF_KEY_ID_9, RF_KEY_EVENT_ID_9_CLICK, RF_KEY_EVENT_ID_9_LONG, RF_KEY_EVENT_ID_9_HOLD, RF_KEY_EVENT_ID
             -_9_LOOSE},      //
 127              {RF_KEY_ID_10, RF_KEY_EVENT_ID_10_CLICK, RF_KEY_EVENT_ID_10_LONG, RF_KEY_EVENT_ID_10_HOLD, RF_KEY_EVEN
             -T_ID_10_LOOSE}, //
 128              {RF_KEY_ID_11, RF_KEY_EVENT_ID_11_CLICK, RF_KEY_EVENT_ID_11_LONG, RF_KEY_EVENT_ID_11_HOLD, RF_KEY_EVEN
             -T_ID_11_LOOSE}, //
 129              {RF_KEY_ID_12, RF_KEY_EVENT_ID_12_CLICK, RF_KEY_EVENT_ID_12_LONG, RF_KEY_EVENT_ID_12_HOLD, RF_KEY_EVEN
             -T_ID_12_LOOSE}, //
 130          
 131          #if USE_MY_TEST_433_REMOTE
              
                  {RF_KEY_ID_TEST_1, RF_KEY_EVENT_ID_TEST_1_CLICK, RF_KEY_EVENT_ID_TEST_1_LONG, RF_KEY_EVENT_ID_TEST_1_H
             -OLD, RF_KEY_EVENT_ID_TEST_1_LOOSE}, //
                  {RF_KEY_ID_TEST_2, RF_KEY_EVENT_ID_TEST_2_CLICK, RF_KEY_EVENT_ID_TEST_2_LONG, RF_KEY_EVENT_ID_TEST_2_H
             -OLD, RF_KEY_EVENT_ID_TEST_2_LOOSE}, //
                  {RF_KEY_ID_TEST_3, RF_KEY_EVENT_ID_TEST_3_CLICK, RF_KEY_EVENT_ID_TEST_3_LONG, RF_KEY_EVENT_ID_TEST_3_H
             -OLD, RF_KEY_EVENT_ID_TEST_3_LOOSE}, //
                  {RF_KEY_ID_TEST_4, RF_KEY_EVENT_ID_TEST_4_CLICK, RF_KEY_EVENT_ID_TEST_4_LONG, RF_KEY_EVENT_ID_TEST_4_H
             -OLD, RF_KEY_EVENT_ID_TEST_4_LOOSE}, //
              
              #endif // #if USE_MY_TEST_433_REMOTE
 139          };
 140          
 141          extern u8 rf_key_get_key_id(void);
 142          volatile struct key_driver_para rf_key_para = {
 143              // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
 144              // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 145              // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
 146              // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
 147              // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
 148              // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 149              // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 150              // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 151              // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
 152              // // .click_cnt = 0,
 153              // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
 154              // // .notify_value = 0,
 155              // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
 156              // .get_value = ad_key_get_key_id,
 157          
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 4   

 158              // .latest_key_val = AD_KEY_ID_NONE,
 159              // .latest_key_event = KEY_EVENT_NONE,
 160          
 161              RF_KEY_SCAN_CIRCLE_TIMES, // .scan_times æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
 162              0,                        // .cur_scan_times æŒ‰é”®æ‰«æé¢‘ç‡, å•ä½msï¼Œç”±1msçš„å®šæ—¶å™¨ä¸­æ–­å†
             -…ç´¯åŠ ï¼Œåœ¨key_driver_scan()ä¸­æ¸…é›¶
 163              // NO_KEY,
 164              0, // .last_key
 165          
 166              0,                   // .filter_value
 167              0,                   // .filter_cnt
 168              RF_KEY_FILTER_TIMES, // .filter_time æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³ï¼ˆrfæŒ‰é”®ä¸æ¶ˆæŠ–ï¼‰
 169          
 170              RF_LONG_PRESS_TIME_THRESHOLD_MS / RF_KEY_SCAN_CIRCLE_TIMES,                                     // .lo
             -ng_time
 171              (RF_LONG_PRESS_TIME_THRESHOLD_MS + RF_HOLD_PRESS_TIME_THRESHOLD_MS) / RF_KEY_SCAN_CIRCLE_TIMES, // .ho
             -ld_time
 172              0,                                                                                              // .pr
             -ess_cnt
 173          
 174              0,                              // .click_cnt
 175              0,                              // .click_delay_cnt
 176              200 / RF_KEY_SCAN_CIRCLE_TIMES, // .click_delay_time
 177              // NO_KEY,
 178              0,                 // .notify_value
 179              KEY_TYPE_RF,       // .key_type
 180              rf_key_get_key_id, // .get_value
 181          
 182              RF_KEY_ID_NONE, // .latest_key_val
 183              KEY_EVENT_NONE, // .latest_key_event
 184          }; // volatile struct key_driver_para rf_key_para
 185          
 186          static u8 rf_key_get_key_id(void)
 187          {
 188   1          if (flag_is_recved_rf_data)
 189   1          {
 190   2              flag_is_recved_rf_data = 0;
 191   2              if (rf_data)
 192   2              {
 193   3                  u8 ret = (u8)rf_data;
 194   3                  if (flag_is_in_rf_learning)
 195   3                  {
 196   4                      // å¦‚æœåœ¨rfå¯¹ç æœŸé—´ï¼Œç›´æ¥è·å–åœ°å€
 197   4                      tmp_rf_addr = ((u32)rf_data >> 8);
 198   4                  }
 199   3                  else
 200   3                  {
 201   4                      // å¦‚æœä¸åœ¨rfå¯¹ç æœŸé—´ï¼Œå¹¶ä¸”é¥æ§å™¨çš„åœ°å€ä¸ä¸€è‡´
 202   4                      if ((rf_data >> 8) != rf_remote_info.rf_addr)
 203   4                      {
 204   5                          ret = NO_KEY;
 205   5                      }
 206   4                  }
 207   3      
 208   3                  rf_data = 0;
 209   3      
 210   3                  return (u8)ret; // ç›´æ¥è·å–é”®å€¼
 211   3              }
 212   2              else
 213   2              {
 214   3                  return NO_KEY;
 215   3              }
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 5   

 216   2          }
 217   1          else
 218   1          {
 219   2              return NO_KEY;
 220   2          }
 221   1      }
 222          
 223          /**
 224           * @brief å°†æŒ‰é”®å€¼å’Œ key_driver_scan å¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
 225           *
 226           * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
 227           * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
 228           * @return u8 åœ¨ rf_key_event_table ä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› RF_KEY_EVEN
             -T_NONE
 229           */
 230          static u8 __rf_key_get_event(const u8 key_val, const u8 key_event)
 231          {
 232   1          volatile u8 ret_key_event = RF_KEY_EVENT_NONE;
 233   1          u8 i = 0;
 234   1          for (; i < ARRAY_SIZE(rf_key_event_table); i++)
 235   1          {
 236   2              // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
 237   2              if (key_val == rf_key_event_table[i][0])
 238   2              {
 239   3                  ret_key_event = rf_key_event_table[i][key_event];
 240   3                  break;
 241   3              }
 242   2          }
 243   1      
 244   1          return ret_key_event;
 245   1      }
 246          
 247          void rf_key_handle(void)
 248          {
 249   1          u8 rf_key_event = RF_KEY_EVENT_NONE;
 250   1      
 251   1          // å¦‚æœæ˜¯æ— æ•ˆçš„æŒ‰é”®ä¿¡æ¯ï¼Œå‡½æ•°ç›´æ¥è¿”å›
 252   1          if (rf_key_para.latest_key_val == RF_KEY_ID_NONE)
 253   1          {
 254   2              return;
 255   2          }
 256   1      
 257   1          rf_key_event = __rf_key_get_event(rf_key_para.latest_key_val, rf_key_para.latest_key_event);
 258   1          rf_key_para.latest_key_val = RF_KEY_ID_NONE;
 259   1          rf_key_para.latest_key_event = KEY_EVENT_NONE;
 260   1      
 261   1          { // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 262   2              static u8 last_key_event = KEY_EVENT_NONE;
 263   2      
 264   2              if (1 == flag_is_in_rf_learning) // å¤„äºrfå¯¹ç æœŸé—´ï¼Œæ‰è¿›å…¥
 265   2              {
 266   3                  // å¦‚æœä¸Šä¸€æ¬¡æ£€æµ‹åˆ°çš„æŒ‰é”®ã€é”®å€¼å’Œäº‹ä»¶ã€‘ ä¸æœ€æ–°æ£€æµ‹åˆ°çš„ã€é”®å€¼å’Œäº‹
             -ä»¶ã€‘ç›¸ç­‰ï¼Œè¯´æ˜æ˜¯åŒä¸€ä¸ªæŒ‰é”®é•¿æŒ‰
 267   3                  if (last_key_event == rf_key_event)
 268   3                  {
 269   4                      // åªæœ‰æŒ‰ä¸‹ å¼€æœº/å…³æœº æŒ‰é”®ï¼Œæ‰è¿›è¡Œå¯¹ç 
 270   4                      if (RF_KEY_EVENT_ID_1_HOLD == rf_key_event ||
 271   4                          RF_KEY_EVENT_ID_12_HOLD == rf_key_event)
 272   4                      {
 273   5                          static u16 hold_cnt = 0;
 274   5                          hold_cnt++;
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 6   

 275   5      
 276   5                          if (hold_cnt >= 1)
 277   5                          {
 278   6                              hold_cnt = 0;
 279   6                              // å­˜æ”¾å¯¹ç çš„åœ°å€
 280   6                              rf_remote_info.is_addr_valid = 0xC5;
 281   6                              rf_remote_info.rf_addr = tmp_rf_addr;
 282   6                              flash_erase_sector(FLASH_START_ADDR);
 283   6                              flash_program(FLASH_START_ADDR, (u8 *)&rf_remote_info, sizeof(rf_remote_info));
 284   6      
 285   6      #if USE_MY_DEBUG
                                      printf("rf learn\n");
                                      printf("learn addr: 0x%x\n", rf_remote_info.rf_addr);
              #endif
 289   6                              flag_is_in_rf_learning = 2; // å¯¹ç å®Œæˆåï¼Œç­‰å¾…æŒ‰é”®æ¾æ‰‹
 290   6                          }
 291   5                      }
 292   4                  }
 293   3                  else
 294   3                  {
 295   4                      last_key_event = rf_key_event;
 296   4                  }
 297   3              }
 298   2              else if (2 == flag_is_in_rf_learning) // ç­‰å¾…å¯¹ç æŒ‰é”®æ¾æ‰‹
 299   2              {
 300   3                  if (RF_KEY_EVENT_ID_1_LOOSE == rf_key_event ||
 301   3                      RF_KEY_EVENT_ID_12_LOOSE == rf_key_event)
 302   3                  {
 303   4                      flag_is_in_rf_learning = 0;
 304   4                      return;
 305   4                  }
 306   3              }
 307   2      
 308   2          } // ç”¨äºè¿›è¡Œå¯¹ç çš„ä»£ç å—
 309   1      
 310   1          // å¦‚æœæŒ‰é”®åœ°å€æ— æ•ˆï¼Œæœªè¿›è¡Œå¯¹ç ï¼Œå‡½æ•°ç›´æ¥è¿”å›ï¼Œä¸è¿›è¡Œé”®å€¼å¤„ç†
 311   1          // æ­£åœ¨è¿›è¡Œå¯¹ç ï¼Œä¸è¿›è¡Œé”®å€¼å¤„ç†
 312   1          if (0xC5 != rf_remote_info.is_addr_valid || flag_is_in_rf_learning)
 313   1          {
 314   2              return;
 315   2          }
 316   1      
 317   1          switch (rf_key_event)
 318   1          {
 319   2          case RF_KEY_EVENT_ID_1_CLICK: // ON/OFF
 320   2          case RF_KEY_EVENT_ID_1_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯ ON/OFF
 321   2      
 322   2              // printf("key 1 click\n");
 323   2      
 324   2              // åªè¦æœ‰ä¸€è·¯å¼€å¯ï¼Œä¾¿è®¤ä¸ºç¯å…‰å·²ç»æ‰“å¼€ï¼š
 325   2              if (get_pwm_channel_0_status() || get_pwm_channel_1_status())
 326   2              {
 327   3                  expect_adjust_pwm_channel_0_duty = 0;
 328   3                  expect_adjust_pwm_channel_1_duty = 0;
 329   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 330   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(0);
 331   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 332   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 333   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 334   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 335   3      
 336   3                  pwm_channel_0_disable();
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 7   

 337   3                  pwm_channel_1_disable();
 338   3      
 339   3                  // printf("all pwm channels are disable\n");
 340   3              }
 341   2              else
 342   2              {
 343   3                  expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 344   3                  expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY;
 345   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 346   3                  adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 347   3      
 348   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 349   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 350   3      
 351   3                  cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 352   3                  set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 353   3      
 354   3                  pwm_channel_0_enable();
 355   3                  pwm_channel_1_enable();
 356   3      
 357   3                  // printf("all pwm channels are enable\n");
 358   3              }
 359   2      
 360   2              break;
 361   2      
 362   2          case RF_KEY_EVENT_ID_2_CLICK: // 1+2æŒ‰é”®ï¼Œäº®åº¦è®¾ç½®ä¸º100%
 363   2          case RF_KEY_EVENT_ID_2_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯ å°† 1+2 äº®åº¦è®¾ç½®ä¸º100%
 364   2      
 365   2              // printf("key 2 click\n");
 366   2      
 367   2              expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 368   2              expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY;
 369   2              adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 370   2              adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_100_PERCENT);
 371   2      
 372   2              cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 373   2              cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 374   2      
 375   2              set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 376   2              set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 377   2      
 378   2              break;
 379   2      
 380   2          case RF_KEY_EVENT_ID_3_CLICK: // å¢åŠ  pwm_channel_0 duty
 381   2      
 382   2              expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 383   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 384   2              {
 385   3                  // é˜²æ­¢æº¢å‡º
 386   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 387   3              }
 388   2      
 389   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 390   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 391   2      
 392   2              break;
 393   2      
 394   2          case RF_KEY_EVENT_ID_3_HOLD: // å¢åŠ  pwm_channel_0 duty
 395   2      
 396   2              expect_adjust_pwm_channel_0_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 397   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 8   

 398   2              {
 399   3                  // é˜²æ­¢æº¢å‡º
 400   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 401   3              }
 402   2      
 403   2              break;
 404   2      
 405   2          case RF_KEY_EVENT_ID_4_CLICK: // å¢åŠ  pwm_channel_1 duty
 406   2      
 407   2              // printf("key 4 click\n");
 408   2              expect_adjust_pwm_channel_1_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 409   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 410   2              {
 411   3                  // é˜²æ­¢æº¢å‡º
 412   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 413   3              }
 414   2      
 415   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 416   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 417   2      
 418   2              break;
 419   2      
 420   2          case RF_KEY_EVENT_ID_4_HOLD: // å¢åŠ  pwm_channel_1 duty
 421   2      
 422   2              expect_adjust_pwm_channel_1_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 423   2              if (expect_adjust_pwm_channel_1_duty > PWM_DUTY_100_PERCENT)
 424   2              {
 425   3                  // é˜²æ­¢æº¢å‡º
 426   3                  expect_adjust_pwm_channel_1_duty = PWM_DUTY_100_PERCENT;
 427   3              }
 428   2      
 429   2              break;
 430   2      
 431   2          case RF_KEY_EVENT_ID_5_CLICK: // set pwm_channel_0 50%
 432   2          case RF_KEY_EVENT_ID_5_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯å°† pwm_channel_0 è®¾ç½®ä¸º50%
 433   2      
 434   2              // printf("key 5 click\n");
 435   2      
 436   2              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 437   2              adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 438   2              cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 439   2              set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 440   2      
 441   2              break;
 442   2      
 443   2          case RF_KEY_EVENT_ID_6_CLICK: // set pwm_channel_1 50%
 444   2          case RF_KEY_EVENT_ID_6_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ä¹Ÿæ˜¯å°† pwm_channel_1 è®¾ç½®ä¸º50%
 445   2      
 446   2              // printf("key 6 click\n");
 447   2      
 448   2              expect_adjust_pwm_channel_1_duty = PWM_DUTY_50_PERCENT;
 449   2              adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 450   2              cur_pwm_channel_1_duty = adjust_pwm_channel_1_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 451   2              set_pwm_channel_1_duty(adjust_pwm_channel_1_duty);
 452   2      
 453   2              break;
 454   2      
 455   2          case RF_KEY_EVENT_ID_7_CLICK: // å‡å° pwm_channel_0 duty
 456   2      
 457   2              // printf("key 7 click\n");
 458   2      
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 9   

 459   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 460   2              {
 461   3                  // expect_adjust_pwm_channel_0_duty -= (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä
             -»¥æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ä¸º100%ï¼‰
 462   3                  expect_adjust_pwm_channel_0_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 463   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 464   3                  {
 465   4                      expect_adjust_pwm_channel_0_duty = 0;
 466   4                  }
 467   3              }
 468   2              else
 469   2              {
 470   3                  // å¦‚æœ  expect_adjust_pwm_channel_0_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 471   3                  expect_adjust_pwm_channel_0_duty = 0;
 472   3              }
 473   2      
 474   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 475   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 476   2      
 477   2              break;
 478   2      
 479   2          case RF_KEY_EVENT_ID_7_HOLD: // å‡å° pwm_channel_0 duty
 480   2      
 481   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 482   2              {
 483   3                  expect_adjust_pwm_channel_0_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 484   3      
 485   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 486   3                  {
 487   4                      expect_adjust_pwm_channel_0_duty = 0;
 488   4                  }
 489   3              }
 490   2              else
 491   2              {
 492   3                  expect_adjust_pwm_channel_0_duty = 0;
 493   3              }
 494   2      
 495   2              break;
 496   2      
 497   2          case RF_KEY_EVENT_ID_8_CLICK: // å‡å° pwm_channel_1 duty
 498   2      
 499   2              // printf("key 8 click\n");
 500   2      
 501   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 502   2              {
 503   3                  expect_adjust_pwm_channel_1_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 504   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 505   3                  {
 506   4                      expect_adjust_pwm_channel_1_duty = 0;
 507   4                  }
 508   3              }
 509   2              else
 510   2              {
 511   3                  // å¦‚æœ  expect_adjust_pwm_channel_1_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 512   3                  expect_adjust_pwm_channel_1_duty = 0;
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 10  

 513   3              }
 514   2      
 515   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 516   2              // adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_1_duty);
 517   2      
 518   2              break;
 519   2      
 520   2          case RF_KEY_EVENT_ID_8_HOLD: // å‡å° pwm_channel_1 duty
 521   2      
 522   2              if (expect_adjust_pwm_channel_1_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 523   2              {
 524   3                  expect_adjust_pwm_channel_1_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 525   3      
 526   3                  if (expect_adjust_pwm_channel_1_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 527   3                  {
 528   4                      expect_adjust_pwm_channel_1_duty = 0;
 529   4                  }
 530   3              }
 531   2              else
 532   2              {
 533   3                  expect_adjust_pwm_channel_1_duty = 0;
 534   3              }
 535   2      
 536   2              break;
 537   2      
 538   2          case RF_KEY_EVENT_ID_9_CLICK: // åŠ å¤§ pwm_channel_0 å ç©ºæ¯”
 539   2      
 540   2              // printf("key 9 click\n");
 541   2      
 542   2              expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 543   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 544   2              {
 545   3                  // é˜²æ­¢æº¢å‡º
 546   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 547   3              }
 548   2      
 549   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 550   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 551   2      
 552   2              break;
 553   2      
 554   2          case RF_KEY_EVENT_ID_9_HOLD: // åŠ å¤§ pwm_channel_0 å ç©ºæ¯”
 555   2      
 556   2              // printf("key id 9 hold\n");
 557   2      
 558   2              /*
 559   2                  ç¤ºä¾‹
 560   2                  é•¿æŒ‰è¦å®ç°æ— æè°ƒèŠ‚ï¼Œæ¯æ¬¡æ£€æµ‹åˆ°HOLDçš„æ—¶é—´é—´éš”ä¸º150msï¼Œç¯å…‰äº®åº¦èŒƒå›´0
             -~6000ï¼Œè°ƒèŠ‚æ—¶é—´3s
 561   2                  æ¯æ¬¡æ£€æµ‹åˆ°HOLDçš„æ—¶é—´é—´éš”ä¸º 50ms ï¼Œç¯å…‰äº®åº¦èŒƒå›´ 0~6000ï¼Œè°ƒèŠ‚æ—¶é—´3sï¼Œé‚£
             -ä¹ˆæ¯æ¬¡HOLDè°ƒèŠ‚ 1.6%
 562   2              */
 563   2      
 564   2              // expect_adjust_pwm_channel_0_duty += (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡ HOLD è°ƒèŠ‚5%
 565   2              expect_adjust_pwm_channel_0_duty += PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / RF_HO
             -LD_PRESS_TIME_THRESHOLD_MS);
 566   2              if (expect_adjust_pwm_channel_0_duty > PWM_DUTY_100_PERCENT)
 567   2              {
 568   3                  // é˜²æ­¢æº¢å‡º
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 11  

 569   3                  expect_adjust_pwm_channel_0_duty = PWM_DUTY_100_PERCENT;
 570   3              }
 571   2      
 572   2              break;
 573   2      
 574   2          case RF_KEY_EVENT_ID_10_CLICK: // è®¾ç½® pwm_channel_0 å ç©ºæ¯”ä¸º50%
 575   2          case RF_KEY_EVENT_ID_10_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ï¼Œä¹Ÿæ˜¯ è®¾ç½® pwm_channel_0 å ç©ºæ¯”ä¸º50%
 576   2      
 577   2              expect_adjust_pwm_channel_0_duty = PWM_DUTY_50_PERCENT;
 578   2              adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(PWM_DUTY_50_PERCENT);
 579   2              cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 580   2              set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 581   2      
 582   2              break;
 583   2      
 584   2          case RF_KEY_EVENT_ID_11_CLICK: // å‡å° pwm_channel_0 å ç©ºæ¯”
 585   2      
 586   2              // printf("key 11 click\n");
 587   2      
 588   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT * 5 / 100)) // å¦‚æœå½“å‰pwmå ç©º
             -æ¯”å¤§äºæœ€å¤§å ç©ºæ¯”çš„5%
 589   2              {
 590   3                  // expect_adjust_pwm_channel_0_duty -= (limited_max_pwm_duty * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%ï¼ˆä
             -»¥æ—‹é’®é™åˆ¶çš„å ç©ºæ¯”ä¸º100%ï¼‰
 591   3                  expect_adjust_pwm_channel_0_duty -= (PWM_DUTY_100_PERCENT * 5 / 100); // æ¯æ¬¡è°ƒèŠ‚5%
 592   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT * 5 / 100))
 593   3                  {
 594   4                      expect_adjust_pwm_channel_0_duty = 0;
 595   4                  }
 596   3              }
 597   2              else
 598   2              {
 599   3                  // å¦‚æœ  expect_adjust_pwm_channel_0_duty å·²ç»å°äº æœ€å¤§å ç©ºæ¯”çš„5% (PWM_DUTY_100_PE
             -RCENT * 5 / 100)
 600   3                  expect_adjust_pwm_channel_0_duty = 0;
 601   3              }
 602   2      
 603   2              // ä¸»å‡½æ•°ä¼šé¢‘ç¹è°ƒç”¨è¯¥è¯­å¥ï¼Œå¯ä»¥ä¼˜åŒ–æ‰ï¼š
 604   2              // adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 605   2      
 606   2              break;
 607   2      
 608   2          case RF_KEY_EVENT_ID_11_HOLD: // å‡å° pwm_channel_0 å ç©ºæ¯”
 609   2      
 610   2              // printf("key id 11 hold\n");
 611   2      
 612   2              if (expect_adjust_pwm_channel_0_duty >= (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / 
             -RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 613   2              {
 614   3                  expect_adjust_pwm_channel_0_duty -= PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD / R
             -F_HOLD_PRESS_TIME_THRESHOLD_MS);
 615   3      
 616   3                  if (expect_adjust_pwm_channel_0_duty < (PWM_DUTY_100_PERCENT / (RF_ADJUST_TOTAL_TIMES_FOR_HOLD
             - / RF_HOLD_PRESS_TIME_THRESHOLD_MS)))
 617   3                  {
 618   4                      expect_adjust_pwm_channel_0_duty = 0;
 619   4                  }
 620   3              }
 621   2              else
 622   2              {
 623   3                  expect_adjust_pwm_channel_0_duty = 0;
 624   3              }
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 12  

 625   2      
 626   2              break;
 627   2      
 628   2          case RF_KEY_EVENT_ID_12_CLICK: // æ§åˆ¶ pwm_channel_0 å¼€å…³çš„æŒ‰é”®
 629   2          case RF_KEY_EVENT_ID_12_LOOSE: // é•¿æŒ‰åæ¾æ‰‹ï¼Œä¹Ÿæ˜¯ æ§åˆ¶ pwm_channel_0 å¼€å…³
 630   2      
 631   2              // printf("key 12 click\n");
 632   2              if (get_pwm_channel_0_status()) // å¦‚æœPWMå·²ç»ä½¿èƒ½
 633   2              {
 634   3                  expect_adjust_pwm_channel_0_duty = 0;
 635   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(0);
 636   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 637   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 638   3                  pwm_channel_0_disable();
 639   3                  // printf("pwm channel 0 is disable\n");
 640   3              }
 641   2              else // å¦‚æœPWMæœªä½¿èƒ½
 642   2              {
 643   3                  expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY;
 644   3                  adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(MAX_PWM_DUTY);
 645   3                  cur_pwm_channel_0_duty = adjust_pwm_channel_0_duty; // æ›´æ–°å½“å‰çš„å ç©ºæ¯”å¯¹åº”çš„æ•°å€¼
 646   3                  set_pwm_channel_0_duty(adjust_pwm_channel_0_duty);
 647   3                  pwm_channel_0_enable();
 648   3                  // printf("pwm channel 0 is enable\n");
 649   3              }
 650   2      
 651   2              break;
 652   2      
 653   2      #if USE_MY_TEST_433_REMOTE // æµ‹è¯•æ—¶ä½¿ç”¨çš„é¥æ§å™¨æŒ‰é”®å’ŒåŠŸèƒ½ï¼Œå®é™…ä¸ä½¿ç”¨
              
                  case RF_KEY_EVENT_ID_TEST_1_CLICK:
              
                      // printf("test 1 click\n");
                      if (limited_max_pwm_duty <= (MAX_PWM_DUTY - 500))
                      {
                          limited_max_pwm_duty += 500;
                      }
              
                      break;
              
                  case RF_KEY_EVENT_ID_TEST_2_CLICK:
              
                      // printf("test 2 click\n");
              
                      if (limited_max_pwm_duty >= (0 + 500))
                      {
                          limited_max_pwm_duty -= 500;
                      }
              
                      break;
              
                  case RF_KEY_EVENT_ID_TEST_3_CLICK:
              
                      // printf("test 3 click\n");
              
                      if (limited_pwm_duty_due_to_temp <= (MAX_PWM_DUTY - 500))
                      {
                          limited_pwm_duty_due_to_temp += 500;
                      }
              
                      break;
              
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 13  

                  case RF_KEY_EVENT_ID_TEST_4_CLICK:
              
                      // printf("test 4 click\n");
              
                      if (limited_pwm_duty_due_to_temp >= (0 + 500))
                      {
                          limited_pwm_duty_due_to_temp -= 500;
                      }
              
                      break;
              
              #endif // #if USE_MY_TEST_433_REMOTE
 699   2      
 700   2          default:
 701   2              break;
 702   2          }
 703   1      }
 704          
 705          void rf_recv_init(void)
 706          {
 707   1      // MY_DEBUG:
 708   1      #if USE_MY_TEST_PIN // æµ‹è¯•æ—¶ä½¿ç”¨ï¼Œåœ¨å¼€å‘æ¿ä¸Šä½¿ç”¨ P01 è„šï¼Œç”¨äºæ£€æµ‹rfä¿¡å·
              
                  P0_PU |= GPIO_P01_PULL_UP(0x01);      // ä¸Šæ‹‰
                  P0_MD0 &= ~(GPIO_P01_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
              
              #else // å®é™…ç”¨åˆ°çš„ã€éæµ‹è¯•æ—¶ä½¿ç”¨çš„rfä¿¡å·æ£€æµ‹å¼•è„šï¼š
 714   1      
 715   1          P0_PU |= GPIO_P03_PULL_UP(0x01);      // ä¸Šæ‹‰
 716   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 717   1      
 718   1      #endif // #if USE_MY_TEST_PIN
 719   1      
 720   1          // æ£€æµ‹æœ‰æ— 433é¥æ§å™¨åŠŸèƒ½çš„å¼•è„šï¼š
 721   1          P1_PU |= GPIO_P11_PULL_UP(0x01);      // ä¸Šæ‹‰
 722   1          P1_MD0 &= ~(GPIO_P11_MODE_SEL(0x03)); // è¾“å…¥æ¨¡å¼
 723   1      
 724   1          if (0 == RF_ENABLE_PIN) // æ£€æµ‹è„šæ¥äº†0Rç”µé˜»åˆ°GNDï¼Œè¯´æ˜æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 725   1          {
 726   2              flag_is_rf_enable = 1;
 727   2          }
 728   1          else // æ£€æµ‹è„šæœªæ¥0Rç”µé˜»ï¼Œè¯´æ˜æ²¡æœ‰433é¥æ§å™¨çš„åŠŸèƒ½
 729   1          {
 730   2              flag_is_rf_enable = 0;
 731   2          }
 732   1      
 733   1          // MY_DEBUG:
 734   1          // flag_is_rf_enable = 1; // æµ‹è¯•æ—¶ä½¿ç”¨ï¼ˆä½¿èƒ½433é¥æ§çš„åŠŸèƒ½ï¼‰
 735   1          // flag_is_rf_enable = 0; // æµ‹è¯•æ—¶ä½¿ç”¨
 736   1      
 737   1          if (flag_is_rf_enable)
 738   1          {
 739   2              flash_read(FLASH_START_ADDR, (u8 *)&rf_remote_info, sizeof(rf_remote_info));
 740   2      
 741   2      #if USE_MY_DEBUG
                      if (0xC5 == rf_remote_info.is_addr_valid)
                      {
                          printf("rf addr valid\n");
                      }
                      else
                      {
                          printf("rf addr unvalid\n");
C51 COMPILER V9.60.7.0   RF_RECV                                                           06/09/2025 18:13:28 PAGE 14  

                      }
              
                      printf("rf addr: 0x %x\n", rf_remote_info.rf_addr);
              #endif
 753   2      
 754   2              flag_is_in_rf_learning = 1; // ä¸Šç”µåï¼Œä½¿èƒ½å¯¹ç åŠŸèƒ½
 755   2          }
 756   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1217    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     92       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
